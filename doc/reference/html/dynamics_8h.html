<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Graspit: C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/include/dynamics.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/include/dynamics.h File Reference</h1>Prototypes for moveBodies and iterateDynamics. This is the heart of the dynamics engine, where all computations are performed. The design is fairly old and had not been update to an object-oriented more modular design, so the functions are hard to read through. However, they get the job done.  
<a href="#_details">More...</a>
<p>

<p>
<a href="dynamics_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>StructDynamicParameters</b></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="acd96c3222f5c5ff05054fef33095bf2"></a><!-- doxytag: member="dynamics.h::ERP" ref="acd96c3222f5c5ff05054fef33095bf2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ERP</b>&nbsp;&nbsp;&nbsp;0.05</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9e8d2d255acfad5b8ee5fccedf20ac24"></a><!-- doxytag: member="dynamics.h::DynamicParameters" ref="9e8d2d255acfad5b8ee5fccedf20ac24" args="" -->
typedef struct <br class="typebreak">
StructDynamicParameters&nbsp;</td><td class="memItemRight" valign="bottom"><b>DynamicParameters</b></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dynamics_8h.html#95dbedd97ede52c0f1fec10e99f2e704">moveBodies</a> (int numBodies, std::vector&lt; <a class="el" href="class_dynamic_body.html">DynamicBody</a> * &gt; bodyVec, double h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves all dynamic bodies for one time step.  <a href="#95dbedd97ede52c0f1fec10e99f2e704"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dynamics_8h.html#1fba7991ba96c0c2231de412256321cd">iterateDynamics</a> (std::vector&lt; <a class="el" href="class_robot.html">Robot</a> * &gt; robotVec, std::vector&lt; <a class="el" href="class_dynamic_body.html">DynamicBody</a> * &gt; bodyVec, DynamicParameters *dp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the new velocites of all bodies, based on contact and joint constraints.  <a href="#1fba7991ba96c0c2231de412256321cd"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Prototypes for moveBodies and iterateDynamics. This is the heart of the dynamics engine, where all computations are performed. The design is fairly old and had not been update to an object-oriented more modular design, so the functions are hard to read through. However, they get the job done. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="1fba7991ba96c0c2231de412256321cd"></a><!-- doxytag: member="dynamics.h::iterateDynamics" ref="1fba7991ba96c0c2231de412256321cd" args="(std::vector&lt; Robot * &gt; robotVec, std::vector&lt; DynamicBody * &gt; bodyVec, DynamicParameters *dp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iterateDynamics           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_robot.html">Robot</a> * &gt;&nbsp;</td>
          <td class="paramname"> <em>robotVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_dynamic_body.html">DynamicBody</a> * &gt;&nbsp;</td>
          <td class="paramname"> <em>bodyVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicParameters *&nbsp;</td>
          <td class="paramname"> <em>dp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the new velocites of all bodies, based on contact and joint constraints. 
<p>
This routine builds a Linear Complementarity Problem (LCP) to solve for the velocities of each dynamic body in a given island of connected dynamic bodies (connected by joints or contacts). The robots and bodies in the island are passed to the routine in the vectors <em>robotVec</em> and <em>bodyVec</em>, and the integration time step <em>h</em> is also provided. The <em>useContactEps</em> flag determines whether error correction will be used for the contacts to ensure non-interpenetration. At the end of the routine, the velocity of each body is updated, as well as all contact and joint forces. 
</div>
</div><p>
<a class="anchor" name="95dbedd97ede52c0f1fec10e99f2e704"></a><!-- doxytag: member="dynamics.h::moveBodies" ref="95dbedd97ede52c0f1fec10e99f2e704" args="(int numBodies, std::vector&lt; DynamicBody * &gt; bodyVec, double h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int moveBodies           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_dynamic_body.html">DynamicBody</a> * &gt;&nbsp;</td>
          <td class="paramname"> <em>bodyVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves all dynamic bodies for one time step. 
<p>
Given a vector of pointers to dynamic bodies, and the number of bodies in the vector, this routine will move those bodies in the direction of their current velocity for the length of the timestep, <em>h</em>. It uses the pre-computed velocities and accelerations computed by iterateDynamics and stored for each body. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jul 24 16:39:08 2009 for Graspit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
