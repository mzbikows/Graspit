<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Graspit: Robot Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Robot Class Reference</h1><!-- doxytag: class="Robot" --><!-- doxytag: inherits="WorldElement" -->Base class for all robots which are collections of links connected by moveable joints.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="robot_8h-source.html">robot.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Robot:</div>
<div class="dynsection">

<p><center><img src="class_robot.png" usemap="#Robot_map" border="0" alt=""></center>
<map name="Robot_map">
<area href="class_world_element.html" alt="WorldElement" shape="rect" coords="49,0,138,24">
<area href="class_hand.html" alt="Hand" shape="rect" coords="0,112,89,136">
<area href="class_puma560.html" alt="Puma560" shape="rect" coords="99,112,188,136">
<area href="class_barrett.html" alt="Barrett" shape="rect" coords="99,168,188,192">
<area href="class_human_hand.html" alt="HumanHand" shape="rect" coords="99,224,188,248">
<area href="class_m7.html" alt="M7" shape="rect" coords="99,280,188,304">
<area href="class_m7_tool.html" alt="M7Tool" shape="rect" coords="99,336,188,360">
<area href="class_mc_grip.html" alt="McGrip" shape="rect" coords="99,392,188,416">
<area href="class_pincer.html" alt="Pincer" shape="rect" coords="99,448,188,472">
<area href="class_pr2_gripper.html" alt="Pr2Gripper" shape="rect" coords="99,504,188,528">
<area href="class_robonaut.html" alt="Robonaut" shape="rect" coords="99,560,188,584">
<area href="class_shadow.html" alt="Shadow" shape="rect" coords="99,616,188,640">
</map>
</div>

<p>
<a href="class_robot-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Signals</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6b57b51e1bffc38c6202da369661f7a1"></a><!-- doxytag: member="Robot::configurationChanged" ref="6b57b51e1bffc38c6202da369661f7a1" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#6b57b51e1bffc38c6202da369661f7a1">configurationChanged</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This signal informs that dof values have changed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="22919b77661daebdec89ce295f868491"></a><!-- doxytag: member="Robot::userInteractionStart" ref="22919b77661daebdec89ce295f868491" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#22919b77661daebdec89ce295f868491">userInteractionStart</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This signal informs that user has begun interaction by clicking on a robot handler. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a18bb8397c8a4696f7993818c6f8ba9c"></a><!-- doxytag: member="Robot::userInteractionEnd" ref="a18bb8397c8a4696f7993818c6f8ba9c" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#a18bb8397c8a4696f7993818c6f8ba9c">userInteractionEnd</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This signal is the complement of <a class="el" href="class_robot.html#22919b77661daebdec89ce295f868491" title="This signal informs that user has begun interaction by clicking on a robot handler...">userInteractionStart()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="54d6e1b756fcd7fdabed1544342c867c"></a><!-- doxytag: member="Robot::moveDOFStepTaken" ref="54d6e1b756fcd7fdabed1544342c867c" args="(int numCols, bool &amp;stopRequest)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#54d6e1b756fcd7fdabed1544342c867c">moveDOFStepTaken</a> (int numCols, bool &amp;stopRequest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emitted by moveDOFToCOntacts each time a step is taken. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#ba80599777cf49105526a59f45d0226b">Robot</a> (<a class="el" href="class_world.html">World</a> *w, const char *name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#924320124b09c2f2ac1621aa210d5f38">~Robot</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes all kinematic chains, the base and mount piece, etc.  <a href="#924320124b09c2f2ac1621aa210d5f38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#855fcd3d460f65286b4f5321fac79c7a">loadFromXml</a> (const TiXmlElement *root, QString rootPath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main load function that loads all the information from XML.  <a href="#855fcd3d460f65286b4f5321fac79c7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#5b8fdcf0a1904657ff52758c94c4331f">cloneFrom</a> (<a class="el" href="class_robot.html">Robot</a> *original)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes this robot into a clone of the original.  <a href="#5b8fdcf0a1904657ff52758c94c4331f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#47098617afecf0cd9004e5ac35ccd47e">moveDOFToContacts</a> (double *desiredVals, double *desiredSteps, bool stopAtContact, bool renderIt=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main way to move robot dofs IN STATICS. Checks collisions and finds contacts.  <a href="#47098617afecf0cd9004e5ac35ccd47e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#22a869d85b2ddfa9772309e9a2bcffd6">setTran</a> (<a class="el" href="classtransf.html">transf</a> const &amp;tr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the location (pose) of the base of this robot in the world coordinate system.  <a href="#22a869d85b2ddfa9772309e9a2bcffd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#992f698d9b900bf275ddfc301f4fab16">forceDOFVal</a> (int dofNum, double val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the given <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> to the given value and updates the link poses. Collisions are NOT checked.  <a href="#992f698d9b900bf275ddfc301f4fab16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#bc99b8a1bb508b84733e0efa67fa1df4">forceDOFVals</a> (double *dofVals)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the values of the DOF's to the values in the array dofVals. Collisions are NOT checked.  <a href="#bc99b8a1bb508b84733e0efa67fa1df4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#e2f41ebd10da92db3e2b65176bae4300">setDesiredDOFVals</a> (double *dofVals)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main way to move the robot dofs IN DYNAMICS mode.  <a href="#e2f41ebd10da92db3e2b65176bae4300"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#d1ed8cfb1b813fc6d4784d5737cfe537">contactSlip</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if any of the contacts on the fingers are slipping during dynamics.  <a href="#d1ed8cfb1b813fc6d4784d5737cfe537"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#0e2dffc10c4d284b4006fb7a046b3d55">dynamicAutograspComplete</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to check if the dynamic autograsp is complete.  <a href="#0e2dffc10c4d284b4006fb7a046b3d55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#7da18a9f273097884173e940f45e5ab2">updateJointValuesFromDynamics</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the joint angles after a dynamic step has been completed.  <a href="#7da18a9f273097884173e940f45e5ab2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#00d673d82837d12241859a2220fb721a">applyJointPassiveInternalWrenches</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies internal joint forces (if any), such as friction or joint springs.  <a href="#00d673d82837d12241859a2220fb721a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#68e785875f61e3d3902d7cabd555663f">DOFController</a> (double timeStep)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls the <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> controllers which set dof forces based on current and desired posture.  <a href="#68e785875f61e3d3902d7cabd555663f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#caf6bc556a76c8c71302bf6b0e95edbb">buildDOFCouplingConstraints</a> (std::map&lt; <a class="el" href="class_body.html">Body</a> *, int &gt; &amp;islandIndices, int numBodies, double *Nu, double *eps, int &amp;ncn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds dynamic constraints for all the coupled dof's of this robot.  <a href="#caf6bc556a76c8c71302bf6b0e95edbb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#22347fa908429bceadfdde8c9258e8ad">buildDOFLimitConstraints</a> (std::map&lt; <a class="el" href="class_body.html">Body</a> *, int &gt; &amp;islandIndices, int numBodies, double *H, double *g, int &amp;hcn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds dynamic dof limit constraints for all the dof's of this robot.  <a href="#22347fa908429bceadfdde8c9258e8ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classtransf.html">transf</a> const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#658cc08ca10d89f4ecb65b759ddf82fe">getTran</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#cd8ae34f5a5569913639a5e9ae530be4">fwdKinematics</a> (double *dofVals, std::vector&lt; <a class="el" href="classtransf.html">transf</a> &gt; &amp;trVec, int chainNum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the transform of all links in a chain for a given set of dof vals.  <a href="#cd8ae34f5a5569913639a5e9ae530be4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#e36c29a2a4d25e5bb6d1be4fb42ea58c">invKinematics</a> (const <a class="el" href="classtransf.html">transf</a> &amp;endTran, double *dofVals, int chainNum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the dofvals that achieve a desired end pose for a chain.  <a href="#e36c29a2a4d25e5bb6d1be4fb42ea58c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#f9c5984171c733083fec50c026dbe514">getDOFVals</a> (double *dofVals) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current values of all of the DOF's of the robot.  <a href="#f9c5984171c733083fec50c026dbe514"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#c0d37d043c9989eb9795e1d2ddb63839">checkDOFVals</a> (double *dofVals) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if all specified dof vals are within their respective legal ranges.  <a href="#c0d37d043c9989eb9795e1d2ddb63839"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#0f5ba2ee89bcd36708173584b9ef899d">checkSetDOFVals</a> (double *dofVals) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clamps the given dofVals to be within their respective legal ranges.  <a href="#0f5ba2ee89bcd36708173584b9ef899d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#6d63c0b70c9a4ed8958c0de1332c11b5">contactsPreventMotion</a> (const <a class="el" href="classtransf.html">transf</a> &amp;motion) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true of contacts on the palm, a link or a parent robot prevent given motion.  <a href="#6d63c0b70c9a4ed8958c0de1332c11b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#db5bcb404db519ce7396382942fb80a8">checkDOFPath</a> (double *desiredVals, double desiredStep)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the path between current and a desired posture is free of collisions.  <a href="#db5bcb404db519ce7396382942fb80a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#56cf0fd4d9202e41e49459f294b3cb1b">updateDOFFromJoints</a> (double *jointVals)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> values based on the current values of the joints.  <a href="#56cf0fd4d9202e41e49459f294b3cb1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#4601ffaf9bfba4c846d1ac11b2e6e2be">jointLimitDist</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the closest distance between a joint value and its limit.  <a href="#4601ffaf9bfba4c846d1ac11b2e6e2be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4397b73a4ab21e78bd57ee30c631782e"></a><!-- doxytag: member="Robot::useCyberGlove" ref="4397b73a4ab21e78bd57ee30c631782e" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#4397b73a4ab21e78bd57ee30c631782e">useCyberGlove</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this robot is controlled by a CyberGlove. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#08cd5eba118b1fe7a27948be45d94e48">setGlove</a> (CyberGlove *glove)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the instance of the class which translates CyberGlove informration for this robot.  <a href="#08cd5eba118b1fe7a27948be45d94e48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#1eb0fa3dc9aa30b6b05559237ee4b8c2">processCyberGlove</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processes a new reading from the CyberGlove.  <a href="#1eb0fa3dc9aa30b6b05559237ee4b8c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="99e76bab08e992b39ecaf1fc274a64c1"></a><!-- doxytag: member="Robot::getGloveInterface" ref="99e76bab08e992b39ecaf1fc274a64c1" args="()" -->
<a class="el" href="class_glove_interface.html">GloveInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#99e76bab08e992b39ecaf1fc274a64c1">getGloveInterface</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the class that interfaces between the CyberGlove and this robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="79cf661790ce74334481d60af2a4169d"></a><!-- doxytag: member="Robot::getBirdNumber" ref="79cf661790ce74334481d60af2a4169d" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#79cf661790ce74334481d60af2a4169d">getBirdNumber</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of the bird that this robot is connected to. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c56123efc23c6a8c615f557b4a3095cd"></a><!-- doxytag: member="Robot::usesFlock" ref="c56123efc23c6a8c615f557b4a3095cd" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#c56123efc23c6a8c615f557b4a3095cd">usesFlock</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this robot is connected to a Flock of Birds. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="40c1f17e9803bb4550083b0868f9515c"></a><!-- doxytag: member="Robot::getFlockTran" ref="40c1f17e9803bb4550083b0868f9515c" args="() const " -->
const <a class="el" href="class_flock_transf.html">FlockTransf</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#40c1f17e9803bb4550083b0868f9515c">getFlockTran</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the transform that indicates where the flock sensor is mounted on this robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c48f1b5473c933db1222046bcc09a35b"></a><!-- doxytag: member="Robot::getFlockTran" ref="c48f1b5473c933db1222046bcc09a35b" args="()" -->
<a class="el" href="class_flock_transf.html">FlockTransf</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#c48f1b5473c933db1222046bcc09a35b">getFlockTran</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the class that keeps track of flock transforms for this robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#9a593f99f71971df3a49547ee403be6c">loadEigenData</a> (QString filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks for and loads eigengrasp information from a given file.  <a href="#9a593f99f71971df3a49547ee403be6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#082748d669c962e5e2a0cbfd27dda21d">useIdentityEigenData</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the trivial eigengrasp set, where we have 1 eg per dof.  <a href="#082748d669c962e5e2a0cbfd27dda21d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ad884933660d4d3b82a9707986c82b20"></a><!-- doxytag: member="Robot::getEigenGrasps" ref="ad884933660d4d3b82a9707986c82b20" args="() const " -->
const <a class="el" href="class_eigen_grasp_interface.html">EigenGraspInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#ad884933660d4d3b82a9707986c82b20">getEigenGrasps</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the eigengrasps of this robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fcf2f890be478b31d38470a5efe9f517"></a><!-- doxytag: member="Robot::getEigenGrasps" ref="fcf2f890be478b31d38470a5efe9f517" args="()" -->
<a class="el" href="class_eigen_grasp_interface.html">EigenGraspInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#fcf2f890be478b31d38470a5efe9f517">getEigenGrasps</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the eigengrasps of this robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual QTextStream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#3b7b34133e1dcabaddc4a10a6d99b4f3">readDOFVals</a> (QTextStream &amp;is)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the values of all dofs from a text stream, then updates posture accordingly.  <a href="#3b7b34133e1dcabaddc4a10a6d99b4f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual QTextStream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#9c3c2eb5373ef987493d733cdc932890">writeDOFVals</a> (QTextStream &amp;os)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the values of all dofs to a text stream.  <a href="#9c3c2eb5373ef987493d733cdc932890"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#ff50d3822abab239c386000147f520ea">saveState</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves the state of the robot (pose and posture). Overwrites any previously saved state.  <a href="#ff50d3822abab239c386000147f520ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#e5b4dccb42a06e62592e278e61de6e06">restoreState</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restores the previously saved state (if any).  <a href="#e5b4dccb42a06e62592e278e61de6e06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#8febe38572c438021598caa882367dc3">getNumContacts</a> (<a class="el" href="class_body.html">Body</a> *body=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of contacts on this robot against a given body.  <a href="#8febe38572c438021598caa882367dc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::list&lt; <a class="el" href="class_contact.html">Contact</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#872c4a5b354b646d2cda5b405123fedc">getContacts</a> (<a class="el" href="class_body.html">Body</a> *body=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all the contacts on this robot against a given body.  <a href="#872c4a5b354b646d2cda5b405123fedc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#81ae77a54fc86c266e934bc9c1df38b1">breakContacts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Breaks all the contacts on this robot.  <a href="#81ae77a54fc86c266e934bc9c1df38b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#7502a98fbbffb65a59fa292c835523aa">getNumVirtualContacts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of virtual contacts on this robot.  <a href="#7502a98fbbffb65a59fa292c835523aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#b3b0496d895489921555786e734bc775">showVirtualContacts</a> (bool on)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shows or hides virtual contacts.  <a href="#b3b0496d895489921555786e734bc775"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#ee5f4f7c0574dc834e37830b09b97153">loadContactData</a> (QString filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks for and loads virtual contact data from a given file.  <a href="#ee5f4f7c0574dc834e37830b09b97153"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b9b573e3c25e5601a087079831720345"></a><!-- doxytag: member="Robot::getBaseRobot" ref="b9b573e3c25e5601a087079831720345" args="()" -->
<a class="el" href="class_robot.html">Robot</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#b9b573e3c25e5601a087079831720345">getBaseRobot</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a chain or tree of connected robots, returns a pointer to the root or base robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="864ddd4af1d27fb2eee447bee5a763a1"></a><!-- doxytag: member="Robot::getParent" ref="864ddd4af1d27fb2eee447bee5a763a1" args="()" -->
<a class="el" href="class_robot.html">Robot</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#864ddd4af1d27fb2eee447bee5a763a1">getParent</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the parent robot (whose chain this robot is connected to). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="69247888998da1cf4733c6409d35d9db"></a><!-- doxytag: member="Robot::getParentChainNum" ref="69247888998da1cf4733c6409d35d9db" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#69247888998da1cf4733c6409d35d9db">getParentChainNum</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the chain that this robot is connected to. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classtransf.html">transf</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#a6253023aa87ef9828dcc87034027387">getTranToParentEnd</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#e2cf0874dd148afa0bbe1732baf8cd43">getAllAttachedRobots</a> (std::vector&lt; <a class="el" href="class_robot.html">Robot</a> * &gt; &amp;robotVec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a vector of all robots attached to this one.  <a href="#e2cf0874dd148afa0bbe1732baf8cd43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#2ee2a70ad923393ba6d27f9dfddb9196">attachRobot</a> (<a class="el" href="class_robot.html">Robot</a> *r, int chainNum, const <a class="el" href="classtransf.html">transf</a> &amp;offsetTr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attaches another robot to the end of a chain of this robot.  <a href="#2ee2a70ad923393ba6d27f9dfddb9196"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#6604c02f4ecbcca5913c670bcd4b6346">detachRobot</a> (<a class="el" href="class_robot.html">Robot</a> *r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detaches a previously attached robot.  <a href="#6604c02f4ecbcca5913c670bcd4b6346"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_link.html">Link</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#f7acef5ce60ba5a7b422d120989688fb">importMountPiece</a> (QString filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads a mount piece from a file, if this robot is atatched to another.  <a href="#f7acef5ce60ba5a7b422d120989688fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c05ac48ce2b522e199058a2db36a7410"></a><!-- doxytag: member="Robot::getMountPiece" ref="c05ac48ce2b522e199058a2db36a7410" args="() const " -->
<a class="el" href="class_link.html">Link</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#c05ac48ce2b522e199058a2db36a7410">getMountPiece</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a point to the mountpiece link (NULL if none exists). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#ed365674e44d6ae90b588cd78a8a615d">snapChainToContacts</a> (int chainNum, <a class="el" href="collision_structures_8h.html#56044fe7fffe7044c92ff5bfae3d56b6">CollisionReport</a> colReport)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#65e48618cdb430dcbc13493486cc8952">setName</a> (QString newName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the name of this robot.  <a href="#65e48618cdb430dcbc13493486cc8952"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#b52feb0c2450237c70f29cdde1a3a8a9">getNumLinks</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of links for this robot (including palm and mount piece).  <a href="#b52feb0c2450237c70f29cdde1a3a8a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f2ed52a270b45bfd50b887ce2d0bc26"></a><!-- doxytag: member="Robot::getNumDOF" ref="0f2ed52a270b45bfd50b887ce2d0bc26" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#0f2ed52a270b45bfd50b887ce2d0bc26">getNumDOF</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of degrees of freedom for this robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aea20fd59bda44999cf1cb64b348520c"></a><!-- doxytag: member="Robot::getDOF" ref="aea20fd59bda44999cf1cb64b348520c" args="(int i) const " -->
<a class="el" href="class_d_o_f.html">DOF</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#aea20fd59bda44999cf1cb64b348520c">getDOF</a> (int i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the i-th <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ac43d80817fad5a3d1d5c8dbcf8bc530"></a><!-- doxytag: member="Robot::getDOFDraggerScale" ref="ac43d80817fad5a3d1d5c8dbcf8bc530" args="(int i) const " -->
float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#ac43d80817fad5a3d1d5c8dbcf8bc530">getDOFDraggerScale</a> (int i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the scale of the i-th <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> dragger. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="17fe591c5c180fb71a99203af14683b0"></a><!-- doxytag: member="Robot::getNumChains" ref="17fe591c5c180fb71a99203af14683b0" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#17fe591c5c180fb71a99203af14683b0">getNumChains</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of kinematic chains in this robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2a8a861caf4da970b89203c361e8c7d0"></a><!-- doxytag: member="Robot::getNumJoints" ref="2a8a861caf4da970b89203c361e8c7d0" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#2a8a861caf4da970b89203c361e8c7d0">getNumJoints</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of joints in this robot, as set when robot was loaded. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="264d6b89d0196674db84c299f1ea6c41"></a><!-- doxytag: member="Robot::getChain" ref="264d6b89d0196674db84c299f1ea6c41" args="(int i) const " -->
<a class="el" href="class_kinematic_chain.html">KinematicChain</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#264d6b89d0196674db84c299f1ea6c41">getChain</a> (int i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the cnumber of kinematic chains in this robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4f1e7dec2cb7826320a532c7db640fd4"></a><!-- doxytag: member="Robot::getBase" ref="4f1e7dec2cb7826320a532c7db640fd4" args="() const " -->
<a class="el" href="class_link.html">Link</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#4f1e7dec2cb7826320a532c7db640fd4">getBase</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to the base link of this robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#31bdce8f030605c1552c3f302bebecf4">setTransparency</a> (float t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the transparency of the entire robot to the given value.  <a href="#31bdce8f030605c1552c3f302bebecf4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="989c2a7433d3054406355482fd9ad6d9"></a><!-- doxytag: member="Robot::getDefaultTranslVel" ref="989c2a7433d3054406355482fd9ad6d9" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#989c2a7433d3054406355482fd9ad6d9">getDefaultTranslVel</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the default translational velocity (mm/sec) for the robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce83acef682ae85fe67c5103afe8a2a6"></a><!-- doxytag: member="Robot::getDefaultRotVel" ref="ce83acef682ae85fe67c5103afe8a2a6" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#ce83acef682ae85fe67c5103afe8a2a6">getDefaultRotVel</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the default rotational velocity (rad/sec) for the robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cdc277ca31f4199107cc2197cd750b05"></a><!-- doxytag: member="Robot::setDefaultTranslVel" ref="cdc277ca31f4199107cc2197cd750b05" args="(double v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#cdc277ca31f4199107cc2197cd750b05">setDefaultTranslVel</a> (double v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the default translational velocity (mm/sec) for the robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b69efa75d493e6d759c16deeebb2a057"></a><!-- doxytag: member="Robot::setDefaultRotVel" ref="b69efa75d493e6d759c16deeebb2a057" args="(double v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#b69efa75d493e6d759c16deeebb2a057">setDefaultRotVel</a> (double v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the default rotational velocity (rad/sec) for the robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#98825e79d62de0df3a087a57f5ce5d49">setRenderGeometry</a> (bool s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the automatic render when the pose or porture of the robot are changed.  <a href="#98825e79d62de0df3a087a57f5ce5d49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="065b0df832fdd26fdcfd666a728f6260"></a><!-- doxytag: member="Robot::getRenderGeometry" ref="065b0df832fdd26fdcfd666a728f6260" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#065b0df832fdd26fdcfd666a728f6260">getRenderGeometry</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the automatic render flag is set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#5d7f8c8a89c82b5221bebac4976a0346">getAllLinks</a> (std::vector&lt; <a class="el" href="class_dynamic_body.html">DynamicBody</a> * &gt; &amp;allLinkVec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a vector of all links associated with this robot.  <a href="#5d7f8c8a89c82b5221bebac4976a0346"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#eec58c22a32c612068efcac030a18854">setChainEndTrajectory</a> (std::vector&lt; <a class="el" href="classtransf.html">transf</a> &gt; &amp;traj, int chainNum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a smooth trajectory so that a given chain goes through a set of poses.  <a href="#eec58c22a32c612068efcac030a18854"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#d93d07c6bda9824f7883ab6befc3f2c7">generateCartesianTrajectory</a> (const <a class="el" href="classtransf.html">transf</a> &amp;startTr, const <a class="el" href="classtransf.html">transf</a> &amp;endTr, std::vector&lt; <a class="el" href="classtransf.html">transf</a> &gt; &amp;traj, double startVel, double endVel=0.0, double timeNeeded=-1.0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a trajectory that interpolates linearly between a start and end poses.  <a href="#d93d07c6bda9824f7883ab6befc3f2c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#1120ee2b640b50172f220900830eb79a">staticJointTorques</a> (bool useDynamicDofForce)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accumulated the total static torques applied at each joint by all dof's.  <a href="#1120ee2b640b50172f220900830eb79a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="187fa4d25a55369891fae87b63df35ac"></a><!-- doxytag: member="Robot::getApproachTran" ref="187fa4d25a55369891fae87b63df35ac" args="() const " -->
<a class="el" href="classtransf.html">transf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#187fa4d25a55369891fae87b63df35ac">getApproachTran</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the pre-defined approach direction for this robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#3581a9c51c47308a96e46d38522daa90">getApproachDistance</a> (<a class="el" href="class_body.html">Body</a> *object, double maxDist)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells us how far along the approach direction a given object is, within a certain limit.  <a href="#3581a9c51c47308a96e46d38522daa90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="89668ad0f38f2fb988c7d50a0ee3f03e"></a><!-- doxytag: member="Robot::emitConfigChange" ref="89668ad0f38f2fb988c7d50a0ee3f03e" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#89668ad0f38f2fb988c7d50a0ee3f03e">emitConfigChange</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emits the configuration changed signal. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b1c9a47b4bb2268e6772ed1f2afbd6e"></a><!-- doxytag: member="Robot::emitUserInteractionStart" ref="3b1c9a47b4bb2268e6772ed1f2afbd6e" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#3b1c9a47b4bb2268e6772ed1f2afbd6e">emitUserInteractionStart</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emits the user interaction start signal. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="248b3cd07c424f3677266284dfde1dbc"></a><!-- doxytag: member="Robot::emitUserInteractionEnd" ref="248b3cd07c424f3677266284dfde1dbc" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#248b3cd07c424f3677266284dfde1dbc">emitUserInteractionEnd</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emits the user interaction ended signal. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#269df7fbc56661c4e016e37f30b09958">addFlockSensorGeometry</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a visual image of the Flock of Birds sensor to the base of the robot.  <a href="#269df7fbc56661c4e016e37f30b09958"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#505599ee2d103fb0d9b58ed877a2b4c5">addApproachGeometry</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a visual indicator of the pre-specified approach direction for this hand.  <a href="#505599ee2d103fb0d9b58ed877a2b4c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#f876d76d560bedc2ca01f5984634c0f3">simpleContactsPreventMotion</a> (const <a class="el" href="classtransf.html">transf</a> &amp;motion) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recurses to all chains of this robot and any attached robots.  <a href="#f876d76d560bedc2ca01f5984634c0f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#9ee6d1d569d41b9ed774350a8f66ab85">simpleSetTran</a> (<a class="el" href="classtransf.html">transf</a> const &amp;tr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An internal method called by setTran.  <a href="#9ee6d1d569d41b9ed774350a8f66ab85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#0948d6118b2c399104bf4e40f3d12a3f">setJointValues</a> (const double *jointVals)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asks all chains to set the given joint values.  <a href="#0948d6118b2c399104bf4e40f3d12a3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#1d0ec1ca019e73ec64f9f36b75a27368">setJointValuesAndUpdate</a> (const double *jointVals)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asks all chains to set the given joint values, then update the <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> of all links.  <a href="#1d0ec1ca019e73ec64f9f36b75a27368"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#5229f71ea0ef819d5f204de80d4d1692">getJointValues</a> (double *jointVals) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current joint values from the chains.  <a href="#5229f71ea0ef819d5f204de80d4d1692"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#26fa557e25d71b81854ee98fb0f78a50">updateDofVals</a> (double *dofVals)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Informs the dof's that certain values have been set.  <a href="#26fa557e25d71b81854ee98fb0f78a50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#4ff737b5823e01287964da418ab41c0d">getJointValuesFromDOF</a> (const double *desireddofVals, double *actualDofVals, double *jointVals, int *stoppedJoints)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Main function for obtaining joint values from the dofs given desired dof values.  <a href="#4ff737b5823e01287964da418ab41c0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="97cf89c0de37e53b42559a4fdfd2a818"></a><!-- doxytag: member="Robot::getJacobianJointToDOF" ref="97cf89c0de37e53b42559a4fdfd2a818" args="(int chainNum)" -->
<a class="el" href="class_matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#97cf89c0de37e53b42559a4fdfd2a818">getJacobianJointToDOF</a> (int chainNum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the Jacobian matrix of Joints w.r.t. <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#1676d2e1bc44c9dc15e5727a7c11cff7">jumpDOFToContact</a> (double *desiredVals, int *stoppedJoints, int *numCols=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to set the desired dof values, detecting contacts along the way.  <a href="#1676d2e1bc44c9dc15e5727a7c11cff7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#a86f42ecc9a7bb8af19a3701b5482df1">interpolateJoints</a> (double *initialVals, double *finalVals, <a class="el" href="collision_structures_8h.html#56044fe7fffe7044c92ff5bfae3d56b6">CollisionReport</a> *colReport, double *interpolationTime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the contact time between a collision and a collision-free posture.  <a href="#a86f42ecc9a7bb8af19a3701b5482df1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#a299ae4e69d2152bb1e0a46b333c111f">stopJointsFromLink</a> (<a class="el" href="class_link.html">Link</a> *link, double *desiredJointVals, int *stoppedJoints)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops all the joints that affect a link that is in contact.  <a href="#a299ae4e69d2152bb1e0a46b333c111f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#a23d3d738d249cbb4bcdd6c634df6996">getBodyList</a> (std::vector&lt; <a class="el" href="class_body.html">Body</a> * &gt; *bodies)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds all of the bodies that make up this robot to the given vector.  <a href="#a23d3d738d249cbb4bcdd6c634df6996"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="471d7a5e8bb073ca5d7590ced25d174c"></a><!-- doxytag: member="Robot::numChains" ref="471d7a5e8bb073ca5d7590ced25d174c" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#471d7a5e8bb073ca5d7590ced25d174c">numChains</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of kinematic chains (or fingers) this robot has. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="09dfed38d9b12b41f96e530e54d92240"></a><!-- doxytag: member="Robot::numDOF" ref="09dfed38d9b12b41f96e530e54d92240" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#09dfed38d9b12b41f96e530e54d92240">numDOF</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of degrees of freedom this robot has. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f0a0d456d8d4c926553df2f61c72a34c"></a><!-- doxytag: member="Robot::numJoints" ref="f0a0d456d8d4c926553df2f61c72a34c" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#f0a0d456d8d4c926553df2f61c72a34c">numJoints</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The total number of joints of this robot. Set when robot is loaded. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d15253d797e1c5a9c3a27be9142a1e08"></a><!-- doxytag: member="Robot::chainVec" ref="d15253d797e1c5a9c3a27be9142a1e08" args="" -->
std::vector&lt; <a class="el" href="class_kinematic_chain.html">KinematicChain</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#d15253d797e1c5a9c3a27be9142a1e08">chainVec</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector of pointers to this robot's kinematic chains. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9d9dabf88663411787224d4664d1d783"></a><!-- doxytag: member="Robot::dofVec" ref="9d9dabf88663411787224d4664d1d783" args="" -->
std::vector&lt; <a class="el" href="class_d_o_f.html">DOF</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#9d9dabf88663411787224d4664d1d783">dofVec</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector of pointers to this robot's DOF's. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="918ffa00dd08447377445d26c0e9500d"></a><!-- doxytag: member="Robot::base" ref="918ffa00dd08447377445d26c0e9500d" args="" -->
<a class="el" href="class_link.html">Link</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#918ffa00dd08447377445d26c0e9500d">base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A pointer to the base link (or palm) of the robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f95caba6f1cf93d5da267b5cb6837e9"></a><!-- doxytag: member="Robot::savedTran" ref="6f95caba6f1cf93d5da267b5cb6837e9" args="" -->
<a class="el" href="classtransf.html">transf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#6f95caba6f1cf93d5da267b5cb6837e9">savedTran</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is used to save the current transform if we want to restore it later. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d14510273c203a2e10e6bcbb039bb6f2"></a><!-- doxytag: member="Robot::savedDOF" ref="d14510273c203a2e10e6bcbb039bb6f2" args="" -->
QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#d14510273c203a2e10e6bcbb039bb6f2">savedDOF</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is used to store the states of the <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a>; a stream is convenient as it can pack all dofs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce3d8196f0019c12fc8708928a3f5c8b"></a><!-- doxytag: member="Robot::savedState" ref="ce3d8196f0019c12fc8708928a3f5c8b" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#ce3d8196f0019c12fc8708928a3f5c8b">savedState</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells us whether the state has been previously saved or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2a4d46b9f9c5df1f0bd60caabf23edbd"></a><!-- doxytag: member="Robot::mRenderGeometry" ref="2a4d46b9f9c5df1f0bd60caabf23edbd" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#2a4d46b9f9c5df1f0bd60caabf23edbd">mRenderGeometry</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether changes to the <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> / geometry of the robot should trigger a scene graph redraw. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6f1fb00cceb130f441cfcb0148b7866"></a><!-- doxytag: member="Robot::dofUpdateTime" ref="b6f1fb00cceb130f441cfcb0148b7866" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#b6f1fb00cceb130f441cfcb0148b7866">dofUpdateTime</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The simulation time of when the next change of <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> setpoints should occur. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="32f4409aa3cb25380eecfe5fb842af35"></a><!-- doxytag: member="Robot::defaultTranslVel" ref="32f4409aa3cb25380eecfe5fb842af35" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#32f4409aa3cb25380eecfe5fb842af35">defaultTranslVel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default translational velocity (mm/sec) to use when generating cartesian trajectories. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="54917668ac49a843242c1a98d726ea58"></a><!-- doxytag: member="Robot::defaultRotVel" ref="54917668ac49a843242c1a98d726ea58" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#54917668ac49a843242c1a98d726ea58">defaultRotVel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default rotational velocity (rad/sec) to use when generating cartesian trajectories. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="29162c0e41d09655f82d6f04cf91aef7"></a><!-- doxytag: member="Robot::mUseCyberGlove" ref="29162c0e41d09655f82d6f04cf91aef7" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#29162c0e41d09655f82d6f04cf91aef7">mUseCyberGlove</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shows if this robot is to be controlled via a CyberGlove. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05d83700c60f26a62436219e3f98971a"></a><!-- doxytag: member="Robot::mGloveInterface" ref="05d83700c60f26a62436219e3f98971a" args="" -->
<a class="el" href="class_glove_interface.html">GloveInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#05d83700c60f26a62436219e3f98971a">mGloveInterface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides translation between the CyberGlove and this robot's DOFs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c16b14e1d8005489b93abad76ce60cd8"></a><!-- doxytag: member="Robot::mUsesFlock" ref="c16b14e1d8005489b93abad76ce60cd8" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#c16b14e1d8005489b93abad76ce60cd8">mUsesFlock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shows if this robot is to be controlled by the Flock of Birds. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b709a4be340f2e40e86945ea397a2b4"></a><!-- doxytag: member="Robot::mBirdNumber" ref="3b709a4be340f2e40e86945ea397a2b4" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#3b709a4be340f2e40e86945ea397a2b4">mBirdNumber</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If robot is controlled by Flock of Birds, shows which bird it is attached to. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="979cc52eab070841fa3ebb7bdd5050ce"></a><!-- doxytag: member="Robot::IVFlockRoot" ref="979cc52eab070841fa3ebb7bdd5050ce" args="" -->
SoSeparator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#979cc52eab070841fa3ebb7bdd5050ce">IVFlockRoot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Geometry for a visual model that shows where the bird is attached to the robot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96106aa11140460bd262259a2e097c2f"></a><!-- doxytag: member="Robot::mFlockTran" ref="96106aa11140460bd262259a2e097c2f" args="" -->
<a class="el" href="class_flock_transf.html">FlockTransf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#96106aa11140460bd262259a2e097c2f">mFlockTran</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The relative tranform used for the Flock of Birds. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ec9c04a136017f3739d63ec63e4a1d35"></a><!-- doxytag: member="Robot::mEigenGrasps" ref="ec9c04a136017f3739d63ec63e4a1d35" args="" -->
<a class="el" href="class_eigen_grasp_interface.html">EigenGraspInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#ec9c04a136017f3739d63ec63e4a1d35">mEigenGrasps</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds all information about this robot's eigengrasps. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classtransf.html">transf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#c2be2fe897ec91403fca7c315b0bd658">approachTran</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pre-specified information on how to best approach an object for grasping.  <a href="#c2be2fe897ec91403fca7c315b0bd658"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="255309e275ac2d86c171c2515bc76081"></a><!-- doxytag: member="Robot::IVApproachRoot" ref="255309e275ac2d86c171c2515bc76081" args="" -->
SoSeparator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_robot.html#255309e275ac2d86c171c2515bc76081">IVApproachRoot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Geometry for the visual model of the approach direction. <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="12bec7c55de9331681fa38e9a0792243"></a><!-- doxytag: member="Robot::KinematicChain::updateLinkPoses" ref="12bec7c55de9331681fa38e9a0792243" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>KinematicChain::updateLinkPoses</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2094c69e3bf07f8c6202b562aa17ba1e"></a><!-- doxytag: member="Robot::KinematicChain::attachRobot" ref="2094c69e3bf07f8c6202b562aa17ba1e" args="(Robot *r, const transf &amp;offsetTr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>KinematicChain::attachRobot</b> (<a class="el" href="class_robot.html">Robot</a> *r, const <a class="el" href="classtransf.html">transf</a> &amp;offsetTr)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Base class for all robots which are collections of links connected by moveable joints. 
<p>
A robot is collection of link bodies orgainized around a base link. Connected to the base link may be 1 or more kinematic chains of links and joints. When a robot is attached to another robot an additional mount piece that connects to the base of the child robot may also be defined. The structure of a robot is defined in a text configuration file [see user documentation] that is parsed by the load method.<p>
Each robot has a collection of DOF's (degrees of freedom) that are linked to the individual joints of a kinematic chain. In general, a robot can not set its joints directly. All joint motion has to be obtained from the DOF's then set using the kinematic chains. In general, we will refer to the <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> of the robot's base in world coordinate systems as the robot's "pose" while the value of the joints (and implicitly the DOF's) is the robot's "posture".<p>
To set the robot pose, think of it as a general <em><a class="el" href="class_world_element.html" title="The base class for all physical elements within the world.">WorldElement</a></em>; nothing complicated here. Posture is more involved, and depends on whether you are in static or dynamic mode.<p>
In static mode, you can have the robot move to some desired *DOF* values. The DOF's will then compute appropriate joint values, and the robot will have the chains execute those. The settings come in two flavors:<p>
<em>moveDOFToContacts</em>(...) will perform the move in small steps and detect contacts along the way. It is guaranteed to leave your robot in a legal configuration, and detect all contacts that occur.<p>
<em>forceDOFVals</em>(...) will force the final joint values and perform no collision detection. Therefore, it might leave the robot in inter-penetration with some other object.<p>
If dynamics are on, then new desired <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> positions are set with a call to <em>setDesiredDOFVals</em>, and a number of intermediate set points are generated for each joint that will ensure a smooth velocity and acceleration profile. Built in PD <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> controllers use gains specified in the robot configuration file to apply approriate forces to each joint to correct error between the current joint <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> and the current set point.<p>
If a linear cartesian moves are desired, a trajectory generator can smoothly interpolate between the desired poses by creating a number of intermediate poses. The inverse kinematics for each of these positions is computed and and the resulting joint positions are used as set points for the PD controllers. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="ba80599777cf49105526a59f45d0226b"></a><!-- doxytag: member="Robot::Robot" ref="ba80599777cf49105526a59f45d0226b" args="(World *w, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Robot::Robot           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_world.html">World</a> *&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simply initializes an empty robot within world w. The load method must be called to read a configuration file and give structure to the robot. 
</div>
</div><p>
<a class="anchor" name="924320124b09c2f2ac1621aa210d5f38"></a><!-- doxytag: member="Robot::~Robot" ref="924320124b09c2f2ac1621aa210d5f38" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Robot::~Robot           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes all kinematic chains, the base and mount piece, etc. 
<p>
Removes the base and mountpiece from the world, and deletes the kinematic chains and DOFs. If this robot is connected to a parent robot, it detaches itself. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="505599ee2d103fb0d9b58ed877a2b4c5"></a><!-- doxytag: member="Robot::addApproachGeometry" ref="505599ee2d103fb0d9b58ed877a2b4c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::addApproachGeometry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a visual indicator of the pre-specified approach direction for this hand. 
<p>
Adds an arrow that shows the pre-defined approach direction for this robot. The arrow is rooted at the origin of the approach direction and points in the z direction of mApproachTran 
</div>
</div><p>
<a class="anchor" name="269df7fbc56661c4e016e37f30b09958"></a><!-- doxytag: member="Robot::addFlockSensorGeometry" ref="269df7fbc56661c4e016e37f30b09958" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::addFlockSensorGeometry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a visual image of the Flock of Birds sensor to the base of the robot. 
<p>
Adds a visual marker that shows where on the robot the Flock of Birds sensor is mounted. Uses the mounting information stored in the mFlockTran, which is usually pre-defined in the robot file 
</div>
</div><p>
<a class="anchor" name="00d673d82837d12241859a2220fb721a"></a><!-- doxytag: member="Robot::applyJointPassiveInternalWrenches" ref="00d673d82837d12241859a2220fb721a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::applyJointPassiveInternalWrenches           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies internal joint forces (if any), such as friction or joint springs. 
<p>
Applies joint friction forces as a pair of equal and opposite forces to links connected at each joint. Frictional forces resist the direction of motion of the joint and uses a viscous friction model with the coefficients defined in the robot configuration file.<p>
Also applies other passive forces, such as spring forces for compliant joints. Spring coefficients are also read from config file. 
</div>
</div><p>
<a class="anchor" name="2ee2a70ad923393ba6d27f9dfddb9196"></a><!-- doxytag: member="Robot::attachRobot" ref="2ee2a70ad923393ba6d27f9dfddb9196" args="(Robot *r, int chainNum, const transf &amp;offsetTr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::attachRobot           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_robot.html">Robot</a> *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chainNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtransf.html">transf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>offsetTr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attaches another robot to the end of a chain of this robot. 
<p>
Given a pointer to a robot, the number of the chain on this robot to connect the new robot to, and the offset transform between the chain end and the base of the new robot, this will attach the new robot to this robot's chain end.<p>
Also disables collision between the link of this robot that the other robot is attached to and the base of the other robot as well as the mount piece. 
</div>
</div><p>
<a class="anchor" name="81ae77a54fc86c266e934bc9c1df38b1"></a><!-- doxytag: member="Robot::breakContacts" ref="81ae77a54fc86c266e934bc9c1df38b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::breakContacts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Breaks all the contacts on this robot. 
<p>
Breaks all the contacts formed on the links or the base of this robot 
</div>
</div><p>
<a class="anchor" name="caf6bc556a76c8c71302bf6b0e95edbb"></a><!-- doxytag: member="Robot::buildDOFCouplingConstraints" ref="caf6bc556a76c8c71302bf6b0e95edbb" args="(std::map&lt; Body *, int &gt; &amp;islandIndices, int numBodies, double *Nu, double *eps, int &amp;ncn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::buildDOFCouplingConstraints           </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_body.html">Body</a> *, int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>islandIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>Nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>ncn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds dynamic constraints for all the coupled dof's of this robot. 
<p>
Transparently goes to each <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> and asks them to build the coupling constraints however they want. See the corresponding <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> functions and users manual for dynamics for details. 
</div>
</div><p>
<a class="anchor" name="22347fa908429bceadfdde8c9258e8ad"></a><!-- doxytag: member="Robot::buildDOFLimitConstraints" ref="22347fa908429bceadfdde8c9258e8ad" args="(std::map&lt; Body *, int &gt; &amp;islandIndices, int numBodies, double *H, double *g, int &amp;hcn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::buildDOFLimitConstraints           </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_body.html">Body</a> *, int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>islandIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>hcn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds dynamic dof limit constraints for all the dof's of this robot. 
<p>
Transparently goes to each <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> and asks them to build the limit constraints however they want. See the corresponding <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> functions and users manual for dynamics for details. 
</div>
</div><p>
<a class="anchor" name="db5bcb404db519ce7396382942fb80a8"></a><!-- doxytag: member="Robot::checkDOFPath" ref="db5bcb404db519ce7396382942fb80a8" args="(double *desiredVals, double desiredStep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Robot::checkDOFPath           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>desiredVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>desiredStep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the path between current and a desired posture is free of collisions. 
<p>
This function checks if the path to the desired vals is legal. Breaks down motion into steps and does each step. As soon as any collision is detected, it returns false. Duplicates a lot of the functionality of moveDOFToContacts. This is not a very good implementation and should probably be cleaned up in the future. 
</div>
</div><p>
<a class="anchor" name="c0d37d043c9989eb9795e1d2ddb63839"></a><!-- doxytag: member="Robot::checkDOFVals" ref="c0d37d043c9989eb9795e1d2ddb63839" args="(double *dofVals) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Robot::checkDOFVals           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dofVals</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if all specified dof vals are within their respective legal ranges. 
<p>
Returns true if all the dof values in <em>dofVals</em> are within their limits 
</div>
</div><p>
<a class="anchor" name="0f5ba2ee89bcd36708173584b9ef899d"></a><!-- doxytag: member="Robot::checkSetDOFVals" ref="0f5ba2ee89bcd36708173584b9ef899d" args="(double *dofVals) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Robot::checkSetDOFVals           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dofVals</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clamps the given dofVals to be within their respective legal ranges. 
<p>
Clamps the dof values in <em>dofVals</em> to be within the dof limits. Returns true if at least one the values in <em>dofVals</em> was within its limit before clamping 
</div>
</div><p>
<a class="anchor" name="5b8fdcf0a1904657ff52758c94c4331f"></a><!-- doxytag: member="Robot::cloneFrom" ref="5b8fdcf0a1904657ff52758c94c4331f" args="(Robot *original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::cloneFrom           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_robot.html">Robot</a> *&nbsp;</td>
          <td class="paramname"> <em>original</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes this robot into a clone of the original. 
<p>
This robot becomes a "clone" of another robot, specified in <em>original</em>. This means that the new robot has its own kinematic structure, DOF's, etc but its links share the geometry of the original robot. See the clone function in the <a class="el" href="class_body.html" title="A generic simulation body.">Body</a> class for details on how that works.<p>
This is generally used for multi-threading, if you want to do spred the computations done on a robot to multiple cores. You then create multiple clones of your robot and pass one to each thread. See the threading documentation in the collision detection classes for details. 
</div>
</div><p>
<a class="anchor" name="d1ed8cfb1b813fc6d4784d5737cfe537"></a><!-- doxytag: member="Robot::contactSlip" ref="d1ed8cfb1b813fc6d4784d5737cfe537" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Robot::contactSlip           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if any of the contacts on the fingers are slipping during dynamics. 
<p>
Looks at dynamics LCP parameters to determine if any of the contacts are slipping during dynamic simulation. Does not do a great job at it, as this turned out to be a much trickier problem than expected. 
</div>
</div><p>
<a class="anchor" name="6d63c0b70c9a4ed8958c0de1332c11b5"></a><!-- doxytag: member="Robot::contactsPreventMotion" ref="6d63c0b70c9a4ed8958c0de1332c11b5" args="(const transf &amp;motion) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Robot::contactsPreventMotion           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtransf.html">transf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>motion</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true of contacts on the palm, a link or a parent robot prevent given motion. 
<p>
Examines all of the contacts on every link of this robot, and each child robot connected to this one, to determine if the desired motion can be performed. It also performs the inverse kinematics of the parent robot to see if any of those link motions will be prevented by contacts on those links. The motion is expressed with respect to the base frame of the robot. This is only used when dynamics are off. 
<p>Implements <a class="el" href="class_world_element.html#bce15363fd8ed89b3944c8b255ed3dce">WorldElement</a>.</p>

</div>
</div><p>
<a class="anchor" name="6604c02f4ecbcca5913c670bcd4b6346"></a><!-- doxytag: member="Robot::detachRobot" ref="6604c02f4ecbcca5913c670bcd4b6346" args="(Robot *r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::detachRobot           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_robot.html">Robot</a> *&nbsp;</td>
          <td class="paramname"> <em>r</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detaches a previously attached robot. 
<p>
The detaches the robot pointed to by <em>r</em> from this robot so that they may move independently. 
</div>
</div><p>
<a class="anchor" name="68e785875f61e3d3902d7cabd555663f"></a><!-- doxytag: member="Robot::DOFController" ref="68e785875f61e3d3902d7cabd555663f" args="(double timeStep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::DOFController           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeStep</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls the <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> controllers which set dof forces based on current and desired posture. 
<p>
If the current simulation time is past the <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> setpoint update time this updates the <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> set points. Then the PD <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> controller for each <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> computes the control force for the <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> given the length of the current timestep. 
<p>Reimplemented in <a class="el" href="class_human_hand.html#61da983bc1eb13aaacb4290a057f3b06">HumanHand</a>, and <a class="el" href="class_pincer.html#4012772a38d6bd034ffdbec545e025d7">Pincer</a>.</p>

</div>
</div><p>
<a class="anchor" name="0e2dffc10c4d284b4006fb7a046b3d55"></a><!-- doxytag: member="Robot::dynamicAutograspComplete" ref="0e2dffc10c4d284b4006fb7a046b3d55" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Robot::dynamicAutograspComplete           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to check if the dynamic autograsp is complete. 
<p>
A specialized function that attempts to see if the autograsp has completed, when executed dynamically. Does not do a great job at it, as this turned out to be a much trickier problem than expected. 
</div>
</div><p>
<a class="anchor" name="992f698d9b900bf275ddfc301f4fab16"></a><!-- doxytag: member="Robot::forceDOFVal" ref="992f698d9b900bf275ddfc301f4fab16" args="(int dofNum, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::forceDOFVal           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dofNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the given <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> to the given value and updates the link poses. Collisions are NOT checked. 
<p>
Forces a single dof to assume a current value. Gets the appropriate joint values from the dofs, then forces the joints to that <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> and updates the posture. Does NOT check for collisions 
</div>
</div><p>
<a class="anchor" name="bc99b8a1bb508b84733e0efa67fa1df4"></a><!-- doxytag: member="Robot::forceDOFVals" ref="bc99b8a1bb508b84733e0efa67fa1df4" args="(double *dofVals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::forceDOFVals           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dofVals</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the values of the DOF's to the values in the array dofVals. Collisions are NOT checked. 
<p>
Sets the values of the dofs of this robot to the values in the array <em>dofVals</em>. Then it updates the link poses, but collisions are NOT checked. 
</div>
</div><p>
<a class="anchor" name="cd8ae34f5a5569913639a5e9ae530be4"></a><!-- doxytag: member="Robot::fwdKinematics" ref="cd8ae34f5a5569913639a5e9ae530be4" args="(double *dofVals, std::vector&lt; transf &gt; &amp;trVec, int chainNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::fwdKinematics           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dofVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtransf.html">transf</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>trVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chainNum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the transform of all links in a chain for a given set of dof vals. 
<p>
Given an array of <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> values equal in length to the number of DOFs in this robot, and the chain number for which the kinematics should be computed, this will return a vector of transforms corresponding to the pose of each link in the chain. 
</div>
</div><p>
<a class="anchor" name="d93d07c6bda9824f7883ab6befc3f2c7"></a><!-- doxytag: member="Robot::generateCartesianTrajectory" ref="d93d07c6bda9824f7883ab6befc3f2c7" args="(const transf &amp;startTr, const transf &amp;endTr, std::vector&lt; transf &gt; &amp;traj, double startVel, double endVel=0.0, double timeNeeded=&#45;1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::generateCartesianTrajectory           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtransf.html">transf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>startTr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtransf.html">transf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endTr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtransf.html">transf</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>startVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>endVel</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeNeeded</em> = <code>-1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes a trajectory that interpolates linearly between a start and end poses. 
<p>
Given a start and end pose, this creates a number of intermediate poses that linearly interpolate between the two in cartesian space. The start and end velocities of the end effector default to 0 but can be changed. If the time needed for the move is not set, the trajectory will have an average velocity equal to the <em>defaultTranVel</em> and <em>defaultRotVel</em>. The number of poses generated is determined by the amount of time needed for the move divided by the default dyanmic time step length. 
</div>
</div><p>
<a class="anchor" name="e2cf0874dd148afa0bbe1732baf8cd43"></a><!-- doxytag: member="Robot::getAllAttachedRobots" ref="e2cf0874dd148afa0bbe1732baf8cd43" args="(std::vector&lt; Robot * &gt; &amp;robotVec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::getAllAttachedRobots           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_robot.html">Robot</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>robotVec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a vector of all robots attached to this one. 
<p>
Returns a pointer to this robot and recursively, all child robots connected to this one 
</div>
</div><p>
<a class="anchor" name="5d7f8c8a89c82b5221bebac4976a0346"></a><!-- doxytag: member="Robot::getAllLinks" ref="5d7f8c8a89c82b5221bebac4976a0346" args="(std::vector&lt; DynamicBody * &gt; &amp;allLinkVec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::getAllLinks           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_dynamic_body.html">DynamicBody</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>allLinkVec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a vector of all links associated with this robot. 
<p>
Returns a vector of all links associated with this robot including all links in all chains, the base, and the mountpiece. 
</div>
</div><p>
<a class="anchor" name="3581a9c51c47308a96e46d38522daa90"></a><!-- doxytag: member="Robot::getApproachDistance" ref="3581a9c51c47308a96e46d38522daa90" args="(Body *object, double maxDist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Robot::getApproachDistance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>maxDist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells us how far along the approach direction a given object is, within a certain limit. 
<p>
Tells us how far along the pre-specified approach distance a certain object is. Since the approach direction might never intersect the given body, it also needs a cap telling is how far to look. This cap is <em>maxDist</em>. Therefore, a return value of <em>maxDist</em> might mean that the object is never hit by moving along the approach direction. 
</div>
</div><p>
<a class="anchor" name="a23d3d738d249cbb4bcdd6c634df6996"></a><!-- doxytag: member="Robot::getBodyList" ref="a23d3d738d249cbb4bcdd6c634df6996" args="(std::vector&lt; Body * &gt; *bodies)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::getBodyList           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_body.html">Body</a> * &gt; *&nbsp;</td>
          <td class="paramname"> <em>bodies</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds all of the bodies that make up this robot to the given vector. 
<p>
Adds all the bodies associated with this robot (links, base, mountpiece, attached robots) to the given vector of bodies. 
<p>Implements <a class="el" href="class_world_element.html#438f8b8bf3f5db942312b9b64cda60a1">WorldElement</a>.</p>

</div>
</div><p>
<a class="anchor" name="872c4a5b354b646d2cda5b405123fedc"></a><!-- doxytag: member="Robot::getContacts" ref="872c4a5b354b646d2cda5b405123fedc" args="(Body *body=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="class_contact.html">Contact</a> * &gt; Robot::getContacts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>body</em> = <code>NULL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns all the contacts on this robot against a given body. 
<p>
Returns the list of contacts on this robot against the <a class="el" href="class_body.html" title="A generic simulation body.">Body</a> <em>body</em>, including contacts on all robot links and the palm. If <em>body</em> is NULL it returns all the contacts on this robot regardless of who they are against. 
</div>
</div><p>
<a class="anchor" name="f9c5984171c733083fec50c026dbe514"></a><!-- doxytag: member="Robot::getDOFVals" ref="f9c5984171c733083fec50c026dbe514" args="(double *dofVals) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::getDOFVals           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dofVals</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current values of all of the DOF's of the robot. 
<p>
<em>dofVals</em> should point to a double array with a length at least equal to the number of DOF's of this robot. 
</div>
</div><p>
<a class="anchor" name="5229f71ea0ef819d5f204de80d4d1692"></a><!-- doxytag: member="Robot::getJointValues" ref="5229f71ea0ef819d5f204de80d4d1692" args="(double *jointVals) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::getJointValues           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>jointVals</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current joint values from the chains. 
<p>
Gets the current joint values in <em>jointVals</em>. It is expected that this vector is of size equal to the number of joints of this robot. 
</div>
</div><p>
<a class="anchor" name="4ff737b5823e01287964da418ab41c0d"></a><!-- doxytag: member="Robot::getJointValuesFromDOF" ref="4ff737b5823e01287964da418ab41c0d" args="(const double *desireddofVals, double *actualDofVals, double *jointVals, int *stoppedJoints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Robot::getJointValuesFromDOF           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>desiredDofVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>actualDofVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>jointVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>stoppedJoints</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Main function for obtaining joint values from the dofs given desired dof values. 
<p>
One of the main functions for moving DOF's in statics. Given a set of <em>desiredDofVals</em>, this will ask the DOF's what values should be given to the joints. The vector <em>stoppedJoints</em> contains information about which joints have been stopped due to contacts. On exit, <em>jointVals</em> will contain the needed joint values, and <em>actualDofVals</em> will contain the <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> values that were actually set (which might be different from <em>desireDofVals</em> because contacts might prevent the desired motion.<p>
The main reason for this implementation is that different types of DOF's react different to contacts and implement coupling in their own differnt way.<p>
Returns <em>true</em> if at least on the joints of the robot is still moving, or  if contacts prevent all motion, limits have been reached and no more movement is possible. 
</div>
</div><p>
<a class="anchor" name="8febe38572c438021598caa882367dc3"></a><!-- doxytag: member="Robot::getNumContacts" ref="8febe38572c438021598caa882367dc3" args="(Body *body=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Robot::getNumContacts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>body</em> = <code>NULL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the total number of contacts on this robot against a given body. 
<p>
Returns the total number of contacts on this robot, including all links and the palm. If <em>body</em> is NULL it returns the total number of contacts on this robot regardless of who they are against. 
</div>
</div><p>
<a class="anchor" name="b52feb0c2450237c70f29cdde1a3a8a9"></a><!-- doxytag: member="Robot::getNumLinks" ref="b52feb0c2450237c70f29cdde1a3a8a9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Robot::getNumLinks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of links for this robot (including palm and mount piece). 
<p>
Returns the total number of links of this robot, including the palm and the mount piece (if any). 
</div>
</div><p>
<a class="anchor" name="7502a98fbbffb65a59fa292c835523aa"></a><!-- doxytag: member="Robot::getNumVirtualContacts" ref="7502a98fbbffb65a59fa292c835523aa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Robot::getNumVirtualContacts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the total number of virtual contacts on this robot. 
<p>
Returns the total number of virtual contacts on this robot, including all links and the palm. 
</div>
</div><p>
<a class="anchor" name="658cc08ca10d89f4ecb65b759ddf82fe"></a><!-- doxytag: member="Robot::getTran" ref="658cc08ca10d89f4ecb65b759ddf82fe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtransf.html">transf</a> const&amp; Robot::getTran           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the transform which describes the world pose of the robot base frame with respect to the world coordinate system. 
<p>Implements <a class="el" href="class_world_element.html#ba4098e4b54f3e3968f12e125d7adbd8">WorldElement</a>.</p>

</div>
</div><p>
<a class="anchor" name="a6253023aa87ef9828dcc87034027387"></a><!-- doxytag: member="Robot::getTranToParentEnd" ref="a6253023aa87ef9828dcc87034027387" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtransf.html">transf</a>&amp; Robot::getTranToParentEnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the transform from the base of this robot to end frame of the parent's kinematic chain that this robot is connected to. 
</div>
</div><p>
<a class="anchor" name="f7acef5ce60ba5a7b422d120989688fb"></a><!-- doxytag: member="Robot::importMountPiece" ref="f7acef5ce60ba5a7b422d120989688fb" args="(QString filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_link.html">Link</a> * Robot::importMountPiece           </td>
          <td>(</td>
          <td class="paramtype">QString&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads a mount piece from a file, if this robot is atatched to another. 
<p>
Given the body filename of a mountpiece, this will load it into the world and connect it to the base of this robot. 
</div>
</div><p>
<a class="anchor" name="a86f42ecc9a7bb8af19a3701b5482df1"></a><!-- doxytag: member="Robot::interpolateJoints" ref="a86f42ecc9a7bb8af19a3701b5482df1" args="(double *initialVals, double *finalVals, CollisionReport *colReport, double *interpolationTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Robot::interpolateJoints           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>initialVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>finalVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="collision_structures_8h.html#56044fe7fffe7044c92ff5bfae3d56b6">CollisionReport</a> *&nbsp;</td>
          <td class="paramname"> <em>colReport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>interpolationTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the contact time between a collision and a collision-free posture. 
<p>
This is one of the core function used for moving the DOF's of a robot in statics. Its purpose is to solve a collision: given an initial set of joint values, which should be collision-free, and a set of final joint values that result in a collision, it will interpolate between the two to find the initial moment of contact (where the bodies are not inter-penetrating, but are separated by less then the contat threshold.<p>
In order to be efficient, it only checks the bodies that are given in the <em>colReport</em>. If other bodies are also colliding at any point during the interpolation, this function will never know about it.<p>
Returns 0 if the interpolation fails (usually because the starting configuration is also in collision, or 1 if its succeeds. In case of success, <em>interpolationTime</em> will hold the interpolation coefficient that resulted in the original contact. 
</div>
</div><p>
<a class="anchor" name="e36c29a2a4d25e5bb6d1be4fb42ea58c"></a><!-- doxytag: member="Robot::invKinematics" ref="e36c29a2a4d25e5bb6d1be4fb42ea58c" args="(const transf &amp;endTran, double *dofVals, int chainNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Robot::invKinematics           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtransf.html">transf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>targetPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dofVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chainNum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the dofvals that achieve a desired end pose for a chain. 
<p>
Given a transform for the end pose of a particular kinematic chain, this will compute the <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> values corresponding to that pose. It will use an iterative approximation technique. In this method, the jacobian is based on each dofs rather than the joint angles 
<p>Reimplemented in <a class="el" href="class_puma560.html#3f24120eb319e349ba320b282c707b9c">Puma560</a>.</p>

</div>
</div><p>
<a class="anchor" name="4601ffaf9bfba4c846d1ac11b2e6e2be"></a><!-- doxytag: member="Robot::jointLimitDist" ref="4601ffaf9bfba4c846d1ac11b2e6e2be" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Robot::jointLimitDist           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the closest distance between a joint value and its limit. 
<p>
Returns the closest distance between a joint value and its limit; positive if the joint is inside its legal range and negative if it's outside 
</div>
</div><p>
<a class="anchor" name="1676d2e1bc44c9dc15e5727a7c11cff7"></a><!-- doxytag: member="Robot::jumpDOFToContact" ref="1676d2e1bc44c9dc15e5727a7c11cff7" args="(double *desiredVals, int *stoppedJoints, int *numCols=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Robot::jumpDOFToContact           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>desiredVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>stoppedJoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>numCols</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to set the desired dof values, detecting contacts along the way. 
<p>
The core of the robot <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> movement in statics. Given a set of <em>desiredVals</em> for the DOF's, it will set the DOF's to that value. If the result is free of contact, we are done. If the result is in collision, it will interpolate to find the exact moment of contact and set the DOF's at that value. <em>stoppedJoints</em> marks any joints that can not move (presumably due to some contact discovered earlier). Returns the number of collisions found (and resolved) in <em>numCols</em>.<p>
After completing the move, it will also mark all the new contacts that have appeared due to the move. It will also mark as stopped the joints of the links that are now in contact, by setting the appropriate bits in <em>stoppedJoints</em>.<p>
In theory, this function should always leave the robot in a legal state, with no inter-penetrations.<p>
Returns <em>true</em> if the move had been performed successfully. Returns <em>false</em> if either no motion was performed because all dofs are already at the desired values, or contacts prevent all motion. Also returns <em>false</em> if there is an error in the interpolation.<p>
A final note of warning: this rather involved way of doing this was dictated by multiple problems: always avoid leaving the robot in an illegal state; allow different dof's to react to stopped joints in their own way; don't compute contacts more often then you have to (it's expensive); make sure the dof's move together, and not one by one; handle the case where the collision detection engine finds a collision, but fails to detect a contact after it's solved (happens very rarely, but it does); etc. In general, this whole process is more complicated than it appears at first. We would love a general and robust solution to this, but tread carefully here. 
</div>
</div><p>
<a class="anchor" name="ee5f4f7c0574dc834e37830b09b97153"></a><!-- doxytag: member="Robot::loadContactData" ref="ee5f4f7c0574dc834e37830b09b97153" args="(QString filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Robot::loadContactData           </td>
          <td>(</td>
          <td class="paramtype">QString&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks for and loads virtual contact data from a given file. 
<p>
Loads all the virtual contacts specified in the file <em>filename</em> 
</div>
</div><p>
<a class="anchor" name="9a593f99f71971df3a49547ee403be6c"></a><!-- doxytag: member="Robot::loadEigenData" ref="9a593f99f71971df3a49547ee403be6c" args="(QString filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Robot::loadEigenData           </td>
          <td>(</td>
          <td class="paramtype">QString&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks for and loads eigengrasp information from a given file. 
<p>
Loads the eigengrasp information from the file <em>filename</em>. 
</div>
</div><p>
<a class="anchor" name="855fcd3d460f65286b4f5321fac79c7a"></a><!-- doxytag: member="Robot::loadFromXml" ref="855fcd3d460f65286b4f5321fac79c7a" args="(const TiXmlElement *root, QString rootPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Robot::loadFromXml           </td>
          <td>(</td>
          <td class="paramtype">const TiXmlElement *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&nbsp;</td>
          <td class="paramname"> <em>rootPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The main load function that loads all the information from XML. 
<p>
Loads the robot information from an XML node, which is asumed to be the root of a hierarchy containing all the relevant information. The <em>rootPath</em> is considered the reference path for other files which are referenced in the XML. One exception are the link files which are assumed to be placed in rootPath/iv 
<p>Reimplemented in <a class="el" href="class_barrett.html#b4c8f956ce31d2105e093ca0f77d2647">Barrett</a>, <a class="el" href="class_human_hand.html#206ca5182679f89aadf3afb8c3410d6e">HumanHand</a>, <a class="el" href="class_m7.html#9d6d8ed1ed085dda0d210f7c14c1ac13">M7</a>, <a class="el" href="class_m7_tool.html#b83191c833ccc55376aace569d129214">M7Tool</a>, <a class="el" href="class_pr2_gripper.html#f5cf4dac924e68cf28c805b6c9de1ad3">Pr2Gripper</a>, <a class="el" href="class_robonaut.html#b53dbb3aafdf7eeaaa99eb2f87423ecc">Robonaut</a>, and <a class="el" href="class_shadow.html#9e6de3342e504ad0b3199cfafe42e156">Shadow</a>.</p>

</div>
</div><p>
<a class="anchor" name="47098617afecf0cd9004e5ac35ccd47e"></a><!-- doxytag: member="Robot::moveDOFToContacts" ref="47098617afecf0cd9004e5ac35ccd47e" args="(double *desiredVals, double *desiredSteps, bool stopAtContact, bool renderIt=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Robot::moveDOFToContacts           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>desiredVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>desiredSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>stopAtContact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>renderIt</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The main way to move robot dofs IN STATICS. Checks collisions and finds contacts. 
<p>
This is the only interface for the user to perform robot <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> movement in statics. The desired dof vals are specified in <em>desiredVals</em>, which should be of size equal to the number of dofs of this robot.<p>
The most important aspect is that the motion can be broken down in small steps, to make sure that no collisions are missed along the way by "jumping through" an obstacle. The other important aspect is that, when a contact is found and a <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> is stopped, the other DOF's can continue to move.<p>
<em>desiredSteps</em> holds the size of the desired steps for each <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a>. We usually use 10 degrees for rotational DOFs and 50*ContactTHRESHOLD for translational DOF's. You can use <a class="el" href="class_world_element.html#9eda0bed4da201d00167ee02c035f9ab" title="Used to indicate moves should be made on one step, not broken down in small steps...">WorldElement::ONE_STEP</a> if no stepping is to be performed. If <em>desiredSteps</em> is NULL it has the same effect as setting all entried to ONE_STEP.<p>
If <em>stopAtContact</em> is true, all movement ends as soon as the first contact is detected. If not, movement proceeds until all DOF's have either reached the desired value, reached their limit, or have been stopped due to contact.<p>
Works by breaking down the motion in small time steps and uses the internal forceDOFTo function repeatedly for each step.Returns true if the joints were moved; if no movement was possible from the beginning, it returns false. 
</div>
</div><p>
<a class="anchor" name="1eb0fa3dc9aa30b6b05559237ee4b8c2"></a><!-- doxytag: member="Robot::processCyberGlove" ref="1eb0fa3dc9aa30b6b05559237ee4b8c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::processCyberGlove           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Processes a new reading from the CyberGlove. 
<p>
Sets the values of the DOF's based on the information from the mGloveInterface, which has presumably processed a new batch of raw information from a real CyberGlove 
</div>
</div><p>
<a class="anchor" name="3b7b34133e1dcabaddc4a10a6d99b4f3"></a><!-- doxytag: member="Robot::readDOFVals" ref="3b7b34133e1dcabaddc4a10a6d99b4f3" args="(QTextStream &amp;is)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QTextStream &amp; Robot::readDOFVals           </td>
          <td>(</td>
          <td class="paramtype">QTextStream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the values of all dofs from a text stream, then updates posture accordingly. 
<p>
Reads <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> values from a text stream (usually from a saved world file or an internally saved state) and sets them 
</div>
</div><p>
<a class="anchor" name="e5b4dccb42a06e62592e278e61de6e06"></a><!-- doxytag: member="Robot::restoreState" ref="e5b4dccb42a06e62592e278e61de6e06" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::restoreState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restores the previously saved state (if any). 
<p>
Restores the previously saved state of this robot. If no state has been saved since the last restore, is prints out a warning, but does not die in pain. 
</div>
</div><p>
<a class="anchor" name="ff50d3822abab239c386000147f520ea"></a><!-- doxytag: member="Robot::saveState" ref="ff50d3822abab239c386000147f520ea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::saveState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the state of the robot (pose and posture). Overwrites any previously saved state. 
<p>
Saves the current state of the robot, which can be restored later. Overwrites any previously saved state. Maybe at some point we will unify this with the stack of dynamic states which can hold any number of states for a body. 
</div>
</div><p>
<a class="anchor" name="eec58c22a32c612068efcac030a18854"></a><!-- doxytag: member="Robot::setChainEndTrajectory" ref="eec58c22a32c612068efcac030a18854" args="(std::vector&lt; transf &gt; &amp;traj, int chainNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::setChainEndTrajectory           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtransf.html">transf</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chainNum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes a smooth trajectory so that a given chain goes through a set of poses. 
<p>
Given a kinematic chain number and a vector of chain end poses, this computes the inverse kinematics for each pose, and computes a smooth trajectory for each <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> to reach each pose. 
</div>
</div><p>
<a class="anchor" name="e2f41ebd10da92db3e2b65176bae4300"></a><!-- doxytag: member="Robot::setDesiredDOFVals" ref="e2f41ebd10da92db3e2b65176bae4300" args="(double *dofVals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::setDesiredDOFVals           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dofVals</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The main way to move the robot dofs IN DYNAMICS mode. 
<p>
This is the main function for moving the robot DOF's in dynamics. All the user can do is set the desired dof vals. This function will compute a smooth trajectory for each joint so that each has a smooth acceleration and velocity profile. The intermediate values become the setpoints for each joint controller.<p>
After that, we rely on the simulation world to run each dynamic time step and call the robot's dof controllers which will set dof dynamic forces based on the desired dof values. The next dynamic time step will then move the links based on the forces applied by the dof's.<p>
In practice, the dof controllers are tricky and I've never been able to make them very robust. They work reasonably well, but not in all cases. 
</div>
</div><p>
<a class="anchor" name="08cd5eba118b1fe7a27948be45d94e48"></a><!-- doxytag: member="Robot::setGlove" ref="08cd5eba118b1fe7a27948be45d94e48" args="(CyberGlove *glove)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::setGlove           </td>
          <td>(</td>
          <td class="paramtype">CyberGlove *&nbsp;</td>
          <td class="paramname"> <em>glove</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the instance of the class which translates CyberGlove informration for this robot. 
<p>
Tells the robot which CyberGlove the raw sensor data is coming from. The robot does not process raw data directly, just passes it to the mGloveInterface which hodsl calibration and <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> mapping between a raw Glove and this particular robot 
</div>
</div><p>
<a class="anchor" name="0948d6118b2c399104bf4e40f3d12a3f"></a><!-- doxytag: member="Robot::setJointValues" ref="0948d6118b2c399104bf4e40f3d12a3f" args="(const double *jointVals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::setJointValues           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>jointVals</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks all chains to set the given joint values. 
<p>
Asks the chains to set the new joint values in <em>jointVals</em>. It is expected that this vector is of size equal to the number of joints of this robot. Does NOT ask the chains to also update the poses of the links. 
</div>
</div><p>
<a class="anchor" name="1d0ec1ca019e73ec64f9f36b75a27368"></a><!-- doxytag: member="Robot::setJointValuesAndUpdate" ref="1d0ec1ca019e73ec64f9f36b75a27368" args="(const double *jointVals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::setJointValuesAndUpdate           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>jointVals</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks all chains to set the given joint values, then update the <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> of all links. 
<p>
Asks the chains to set the new joint values in <em>jointVals</em>. It is expected that this vector is of size equal to the number of joints of this robot. Also asks the chains to also update the poses of the links. 
</div>
</div><p>
<a class="anchor" name="65e48618cdb430dcbc13493486cc8952"></a><!-- doxytag: member="Robot::setName" ref="65e48618cdb430dcbc13493486cc8952" args="(QString newName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::setName           </td>
          <td>(</td>
          <td class="paramtype">QString&nbsp;</td>
          <td class="paramname"> <em>newName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the name of this robot. 
<p>
Sets the name <em>newName</em> for the robot, as well as derived names of the form newName_chain::_link# for the links and newName_base for the base. 
<p>Reimplemented from <a class="el" href="class_world_element.html#54c8856c175bd2bdd97f29015c2fd0e9">WorldElement</a>.</p>

</div>
</div><p>
<a class="anchor" name="98825e79d62de0df3a087a57f5ce5d49"></a><!-- doxytag: member="Robot::setRenderGeometry" ref="98825e79d62de0df3a087a57f5ce5d49" args="(bool s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::setRenderGeometry           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables the automatic render when the pose or porture of the robot are changed. 
<p>
This can be used to disable / enable the automatic render requests from this robot. If this is disabled, changes to the robot pose or posture should not trigger an automatic render request through Coin. The robot however is still part of the scene graph, so whenever a render request comes from someplace else, the robot is rendered in its most current state. See also the option in the <a class="el" href="class_world.html" title="The simulation world holds the world elements and handles their static and dynamic...">World</a> class to completely remove a robot from the scene graph. 
</div>
</div><p>
<a class="anchor" name="22a869d85b2ddfa9772309e9a2bcffd6"></a><!-- doxytag: member="Robot::setTran" ref="22a869d85b2ddfa9772309e9a2bcffd6" args="(transf const &amp;tr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Robot::setTran           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtransf.html">transf</a> const &amp;&nbsp;</td>
          <td class="paramname"> <em>tr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the location (pose) of the base of this robot in the world coordinate system. 
<p>
This attempt to set the pose of the robot base to tr. It does not check for collisions, but it will check the inverse kinematics of a parent robot (if it exists) to determine whether the move is valid. If it is valid the DOF's of the parent are set, and this robot and all of its children are moved. 
<p>Implements <a class="el" href="class_world_element.html#5a8bfa3f84fbf23bbcf4c3c80fc1eb6b">WorldElement</a>.</p>

</div>
</div><p>
<a class="anchor" name="31bdce8f030605c1552c3f302bebecf4"></a><!-- doxytag: member="Robot::setTransparency" ref="31bdce8f030605c1552c3f302bebecf4" args="(float t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::setTransparency           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the transparency of the entire robot to the given value. 
<p>
Sets the transparency of all the links that make up this robot, as well as the base 
</div>
</div><p>
<a class="anchor" name="b3b0496d895489921555786e734bc775"></a><!-- doxytag: member="Robot::showVirtualContacts" ref="b3b0496d895489921555786e734bc775" args="(bool on)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::showVirtualContacts           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>on</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shows or hides virtual contacts. 
<p>
Shows or hides the virtual contact on this robot (which can be shown as thin red cylinders). They are usually hidden so they don't trigger a redraw when not wanted, although we now have a better mechanism for that using setRenderGeometry on the entire robot 
</div>
</div><p>
<a class="anchor" name="f876d76d560bedc2ca01f5984634c0f3"></a><!-- doxytag: member="Robot::simpleContactsPreventMotion" ref="f876d76d560bedc2ca01f5984634c0f3" args="(const transf &amp;motion) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Robot::simpleContactsPreventMotion           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtransf.html">transf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>motion</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recurses to all chains of this robot and any attached robots. 
<p>
This is an internal method called by contactsPreventMotion. Given a motion transform for an entire robot that is defined with respect to the base frame of the robot, it recursively checks all of the kinematic chains of the robot and any robots connected to them to determine if any contacts will prevent the motion. 
</div>
</div><p>
<a class="anchor" name="9ee6d1d569d41b9ed774350a8f66ab85"></a><!-- doxytag: member="Robot::simpleSetTran" ref="9ee6d1d569d41b9ed774350a8f66ab85" args="(transf const &amp;tr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::simpleSetTran           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtransf.html">transf</a> const &amp;&nbsp;</td>
          <td class="paramname"> <em>tr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An internal method called by setTran. 
<p>
Sets the transform of the base link, the mount piece (if it exists), and tells each kinematic chain to update the link poses, which also updates the pose of each attached robot. 
</div>
</div><p>
<a class="anchor" name="ed365674e44d6ae90b588cd78a8a615d"></a><!-- doxytag: member="Robot::snapChainToContacts" ref="ed365674e44d6ae90b588cd78a8a615d" args="(int chainNum, CollisionReport colReport)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Robot::snapChainToContacts           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chainNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="collision_structures_8h.html#56044fe7fffe7044c92ff5bfae3d56b6">CollisionReport</a>&nbsp;</td>
          <td class="paramname"> <em>colReport</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function snaps a kinematic chain out of collision with an object and into contact - if possible. It moves the chain "out" (in the opposite direction of autograsp) a little bit. If this is a valid <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a>, it interpolates between it and the original collision <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> to find the moment of contact. 
</div>
</div><p>
<a class="anchor" name="1120ee2b640b50172f220900830eb79a"></a><!-- doxytag: member="Robot::staticJointTorques" ref="1120ee2b640b50172f220900830eb79a" args="(bool useDynamicDofForce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Robot::staticJointTorques           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useDynamicDofForce</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accumulated the total static torques applied at each joint by all dof's. 
<p>
Returns the static torques on all the joints of this robot. This is relevant for underactuated compliant hands only, should be zero in all other cases. See the <a class="el" href="class_compliant_d_o_f.html">CompliantDOF</a> class for details.<p>
If  is set, the static joint torques are computed using the dynamic force currently set by each <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a>. If not, the minimum values for balancing the system are computed. This is somewhat hacky as this is done in statics, not dynamics, but we needed a way of computing static joint torques for some pre-specified level of <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> force. 
</div>
</div><p>
<a class="anchor" name="a299ae4e69d2152bb1e0a46b333c111f"></a><!-- doxytag: member="Robot::stopJointsFromLink" ref="a299ae4e69d2152bb1e0a46b333c111f" args="(Link *link, double *desiredJointVals, int *stoppedJoints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::stopJointsFromLink           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_link.html">Link</a> *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>desiredJointVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>stoppedJoints</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stops all the joints that affect a link that is in contact. 
<p>
A utility function for the main static <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> movement functions. Given a link that is stopped (presumably due to some contact) it will mark all the joints that affect that link as stopped. This is done by setting the a bit in the entry that correspinds to a given joint in the vector <em>stoppedJoints</em>. <em>stoppedJoints</em> is assumed to be large enough for all the joints in the robot. 
</div>
</div><p>
<a class="anchor" name="56cf0fd4d9202e41e49459f294b3cb1b"></a><!-- doxytag: member="Robot::updateDOFFromJoints" ref="56cf0fd4d9202e41e49459f294b3cb1b" args="(double *jointVals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::updateDOFFromJoints           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>jointVals</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> values based on the current values of the joints. 
<p>
Asks each dof to update its value based on the joint values supplied in <em>jointVals</em> 
</div>
</div><p>
<a class="anchor" name="26fa557e25d71b81854ee98fb0f78a50"></a><!-- doxytag: member="Robot::updateDofVals" ref="26fa557e25d71b81854ee98fb0f78a50" args="(double *dofVals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::updateDofVals           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dofVals</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Informs the dof's that certain values have been set. 
<p>
Informs the dofs of their new values in <em>dofVals</em>. Simply passes through to the similar function of each dof 
</div>
</div><p>
<a class="anchor" name="7da18a9f273097884173e940f45e5ab2"></a><!-- doxytag: member="Robot::updateJointValuesFromDynamics" ref="7da18a9f273097884173e940f45e5ab2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Robot::updateJointValuesFromDynamics           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the joint angles after a dynamic step has been completed. 
<p>
This is only called when dynamics is on. It updates the joint values of the dynamic joints. It is important that this be called after each dynamic movement because other function then look at joint-&gt;getVal() for many different reasons. 
</div>
</div><p>
<a class="anchor" name="082748d669c962e5e2a0cbfd27dda21d"></a><!-- doxytag: member="Robot::useIdentityEigenData" ref="082748d669c962e5e2a0cbfd27dda21d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Robot::useIdentityEigenData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the trivial eigengrasp set, where we have 1 eg per dof. 
<p>
Sets the robot to use the trivial eigengrasps set, where each eigengrasp corresponds to a single <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> with an amplitude of 1.0. In this case, there is no difference between seting EG's and using DOF's directly. 
</div>
</div><p>
<a class="anchor" name="9c3c2eb5373ef987493d733cdc932890"></a><!-- doxytag: member="Robot::writeDOFVals" ref="9c3c2eb5373ef987493d733cdc932890" args="(QTextStream &amp;os)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QTextStream &amp; Robot::writeDOFVals           </td>
          <td>(</td>
          <td class="paramtype">QTextStream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the values of all dofs to a text stream. 
<p>
Writes <a class="el" href="class_d_o_f.html" title="A single degree of freedom in a robot.">DOF</a> values to a text stream (usually a world save file or the internally saved state) 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="c2be2fe897ec91403fca7c315b0bd658"></a><!-- doxytag: member="Robot::approachTran" ref="c2be2fe897ec91403fca7c315b0bd658" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtransf.html">transf</a> <a class="el" href="class_robot.html#c2be2fe897ec91403fca7c315b0bd658">Robot::approachTran</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pre-specified information on how to best approach an object for grasping. 
<p>
This transform sets the origin and the z axis to match the best approach direction for this hand 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/include/<a class="el" href="robot_8h-source.html">robot.h</a><li>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/debug/moc_robot.cpp<li>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/src/<a class="el" href="robot_8cpp.html">robot.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jul 24 16:39:14 2009 for Graspit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
