<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Graspit: CollisionInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CollisionInterface Class Reference</h1><!-- doxytag: class="CollisionInterface" --><code>#include &lt;<a class="el" href="collision_interface_8h-source.html">collisionInterface.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for CollisionInterface:</div>
<div class="dynsection">

<p><center><img src="class_collision_interface.png" usemap="#CollisionInterface_map" border="0" alt=""></center>
<map name="CollisionInterface_map">
<area href="class_p_q_p_collision.html" alt="PQPCollision" shape="rect" coords="0,56,110,80">
</map>
</div>

<p>
<a href="class_collision_interface-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#bdf5bed438d78756aa56d9dc4761bffe">DetectionType</a> { <b>FAST_COLLISION</b>, 
<b>ALL_COLLISIONS</b>
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#e30602245014c005a1dd3c69ed665079">CollisionInterface</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the threading mechanism.  <a href="#e30602245014c005a1dd3c69ed665079"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5bddf47cafa20310b2df1e64d512a001"></a><!-- doxytag: member="CollisionInterface::~CollisionInterface" ref="5bddf47cafa20310b2df1e64d512a001" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#5bddf47cafa20310b2df1e64d512a001">~CollisionInterface</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stub, does nothing. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2ae0481b0284fc0836fb9940e020d679"></a><!-- doxytag: member="CollisionInterface::addBody" ref="2ae0481b0284fc0836fb9940e020d679" args="(Body *body)=0" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#2ae0481b0284fc0836fb9940e020d679">addBody</a> (<a class="el" href="class_body.html">Body</a> *body)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new body to the collision detection system. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="12fcfe7285eb502d81c7935077c33bcd"></a><!-- doxytag: member="CollisionInterface::removeBody" ref="12fcfe7285eb502d81c7935077c33bcd" args="(Body *body)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#12fcfe7285eb502d81c7935077c33bcd">removeBody</a> (<a class="el" href="class_body.html">Body</a> *body)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a body from the collision detection system. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#d91750f7b4abf9a93e8f93d642ddfc2a">cloneBody</a> (<a class="el" href="class_body.html">Body</a> *clone, const <a class="el" href="class_body.html">Body</a> *original)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1bcfe81fd3c048653fd3ce8bc08495cd"></a><!-- doxytag: member="CollisionInterface::setBodyTransform" ref="1bcfe81fd3c048653fd3ce8bc08495cd" args="(Body *body, const transf &amp;t)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#1bcfe81fd3c048653fd3ce8bc08495cd">setBodyTransform</a> (<a class="el" href="class_body.html">Body</a> *body, const <a class="el" href="classtransf.html">transf</a> &amp;t)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> of a body in the collision detection system. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#d1ed2d002e7105f5c18ffa979162bc94">activateBody</a> (const <a class="el" href="class_body.html">Body</a> *body, bool active)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Activates / deactivates a body inside the collision detection system.  <a href="#d1ed2d002e7105f5c18ffa979162bc94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d7ffa5dd085c72098f92d515a038a79"></a><!-- doxytag: member="CollisionInterface::activatePair" ref="3d7ffa5dd085c72098f92d515a038a79" args="(const Body *body1, const Body *body2, bool active)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#3d7ffa5dd085c72098f92d515a038a79">activatePair</a> (const <a class="el" href="class_body.html">Body</a> *body1, const <a class="el" href="class_body.html">Body</a> *body2, bool active)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Toggles collision between a particular pair of bodies. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#35e0791b1846c98a1592b6ac66e9c8d8">isActive</a> (const <a class="el" href="class_body.html">Body</a> *body1, const <a class="el" href="class_body.html">Body</a> *body2=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells us if collisions for a body in general, or a particular pair of bodies, are active.  <a href="#35e0791b1846c98a1592b6ac66e9c8d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#fe82a9777ea788baaf6f288384abb026">allCollisions</a> (<a class="el" href="class_collision_interface.html#bdf5bed438d78756aa56d9dc4761bffe">DetectionType</a> type, <a class="el" href="collision_structures_8h.html#56044fe7fffe7044c92ff5bfae3d56b6">CollisionReport</a> *report, const std::vector&lt; <a class="el" href="class_body.html">Body</a> * &gt; *interestList)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#fc5c850fd451344531d386f0631fb54f">allContacts</a> (<a class="el" href="collision_structures_8h.html#56044fe7fffe7044c92ff5bfae3d56b6">CollisionReport</a> *report, double threshold, const std::vector&lt; <a class="el" href="class_body.html">Body</a> * &gt; *interestList)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#ddf2610315423a5abf7d4af9ce12c13b">contact</a> (<a class="el" href="collision_structures_8h.html#3dea7f9d0c7c38bbb00ecba267b55a6e">ContactReport</a> *report, double threshold, const <a class="el" href="class_body.html">Body</a> *body1, const <a class="el" href="class_body.html">Body</a> *body2)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#372915f17e475dc4007eba4b7fd05b32">pointToBodyDistance</a> (const <a class="el" href="class_body.html">Body</a> *body1, <a class="el" href="classposition.html">position</a> point, <a class="el" href="classposition.html">position</a> &amp;closestPoint, <a class="el" href="classvec3.html">vec3</a> &amp;closestNormal)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#74785f85922ade48b3a91520c30dd9c9">bodyToBodyDistance</a> (const <a class="el" href="class_body.html">Body</a> *body1, const <a class="el" href="class_body.html">Body</a> *body2, <a class="el" href="classposition.html">position</a> &amp;p1, <a class="el" href="classposition.html">position</a> &amp;p2)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#d0f2c48969c77c6e7fc61db007c60e70">bodyRegion</a> (const <a class="el" href="class_body.html">Body</a> *body, <a class="el" href="classposition.html">position</a> point, <a class="el" href="classvec3.html">vec3</a> normal, double radius, <a class="el" href="collision_structures_8h.html#0c91a12f5ded514706e730bf7fb60312">Neighborhood</a> *neighborhood)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="332a48b1bee0e8be697a53e654be72d9"></a><!-- doxytag: member="CollisionInterface::getBoundingVolumes" ref="332a48b1bee0e8be697a53e654be72d9" args="(const Body *, int, std::vector&lt; BoundingBox &gt; *)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#332a48b1bee0e8be697a53e654be72d9">getBoundingVolumes</a> (const <a class="el" href="class_body.html">Body</a> *, int, std::vector&lt; <a class="el" href="class_bounding_box.html">BoundingBox</a> &gt; *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the bounding box hierarchy at a certin depth for a body. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#c6741d233871c3a2cbb5b8cb1402f423">newThread</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#e669ef20e964664403c0f41e11919b84">getThreadId</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#32f4bf7b4e70031515e3f025ba9ba21f">CONTACT_DUPLICATE_THRESHOLD</a> = 3.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two contacts that are separated by less than this are considered the same.  <a href="#32f4bf7b4e70031515e3f025ba9ba21f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#cf32c3f64cc36a9710fa9a25f9cdbabe">compactContactSet</a> (<a class="el" href="collision_structures_8h.html#3dea7f9d0c7c38bbb00ecba267b55a6e">ContactReport</a> *contacts)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#88d63adcec6fecd02c9cd40c8057ecc2">removeContactDuplicates</a> (<a class="el" href="collision_structures_8h.html#3dea7f9d0c7c38bbb00ecba267b55a6e">ContactReport</a> *contacts, double duplicateThreshold)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the duplicate contacts from a contact report.  <a href="#88d63adcec6fecd02c9cd40c8057ecc2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9adcd7a47edcb3d0e70d1ecbeb057e25"></a><!-- doxytag: member="CollisionInterface::mMutex" ref="9adcd7a47edcb3d0e70d1ecbeb057e25" args="" -->
static QMutex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_collision_interface.html#9adcd7a47edcb3d0e70d1ecbeb057e25">mMutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex for synchronizing access to the threading mechanism. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class provides an interface between the GraspIt core and the collision detection libraries.<p>
Core code should never call collision detection libraries directly, but use this abstract class instead. For any collision detection library you want to use, implement this interface class using that library. <hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="bdf5bed438d78756aa56d9dc4761bffe"></a><!-- doxytag: member="CollisionInterface::DetectionType" ref="bdf5bed438d78756aa56d9dc4761bffe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_collision_interface.html#bdf5bed438d78756aa56d9dc4761bffe">CollisionInterface::DetectionType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
FAST_COLLISION is used to ask if any collision exists in the world. ALL_COLLISIONS is used to ask for all the collisions in the world 
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e30602245014c005a1dd3c69ed665079"></a><!-- doxytag: member="CollisionInterface::CollisionInterface" ref="e30602245014c005a1dd3c69ed665079" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CollisionInterface::CollisionInterface           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the threading mechanism. 
<p>
By definition, any <a class="el" href="class_collision_interface.html">CollisionInterface</a> is created with threadId 0, which is the main thread.<p>
In general, you should not use multiple instances of the <a class="el" href="class_collision_interface.html">CollisionInterface</a> and the one instance should be constructed in the main thread. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d1ed2d002e7105f5c18ffa979162bc94"></a><!-- doxytag: member="CollisionInterface::activateBody" ref="d1ed2d002e7105f5c18ffa979162bc94" args="(const Body *body, bool active)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CollisionInterface::activateBody           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>active</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Activates / deactivates a body inside the collision detection system. 
<p>
If a body is deactivated, it is not removed from the system, but it stops producing either collisions or contacts. Can be re-activated any time desired, it is very cheap. 
<p>Implemented in <a class="el" href="class_p_q_p_collision.html#495b1c8c58fd5ba2d5981d953bad5e51">PQPCollision</a>.</p>

</div>
</div><p>
<a class="anchor" name="fe82a9777ea788baaf6f288384abb026"></a><!-- doxytag: member="CollisionInterface::allCollisions" ref="fe82a9777ea788baaf6f288384abb026" args="(DetectionType type, CollisionReport *report, const std::vector&lt; Body * &gt; *interestList)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int CollisionInterface::allCollisions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_collision_interface.html#bdf5bed438d78756aa56d9dc4761bffe">DetectionType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="collision_structures_8h.html#56044fe7fffe7044c92ff5bfae3d56b6">CollisionReport</a> *&nbsp;</td>
          <td class="paramname"> <em>report</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_body.html">Body</a> * &gt; *&nbsp;</td>
          <td class="paramname"> <em>interestList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Goes through all the bodies in the world and returns collisions. If <em>type</em> is FAST_COLLISION, returns 1 as soon as any collision is found. If <em>type</em> is ALL_COLLISIONS, returns the total number of collisions in the world.<p>
The list of all colliding bodies is placed in the <em>report</em>.<p>
If an  is passed, then it only queries for collisions involving at least one body in the list. 
<p>Implemented in <a class="el" href="class_p_q_p_collision.html#0cec40e441278d3343683078e49a9c78">PQPCollision</a>.</p>

</div>
</div><p>
<a class="anchor" name="fc5c850fd451344531d386f0631fb54f"></a><!-- doxytag: member="CollisionInterface::allContacts" ref="fc5c850fd451344531d386f0631fb54f" args="(CollisionReport *report, double threshold, const std::vector&lt; Body * &gt; *interestList)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int CollisionInterface::allContacts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="collision_structures_8h.html#56044fe7fffe7044c92ff5bfae3d56b6">CollisionReport</a> *&nbsp;</td>
          <td class="paramname"> <em>report</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_body.html">Body</a> * &gt; *&nbsp;</td>
          <td class="paramname"> <em>interestList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds all the contacts in the world. <em>interestList</em> is used the same way as in <em><a class="el" href="class_collision_interface.html#fe82a9777ea788baaf6f288384abb026">allCollisions()</a></em>. 
<p>Implemented in <a class="el" href="class_p_q_p_collision.html#c930d74e0b5f8f78651a67807e317310">PQPCollision</a>.</p>

</div>
</div><p>
<a class="anchor" name="d0f2c48969c77c6e7fc61db007c60e70"></a><!-- doxytag: member="CollisionInterface::bodyRegion" ref="d0f2c48969c77c6e7fc61db007c60e70" args="(const Body *body, position point, vec3 normal, double radius, Neighborhood *neighborhood)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CollisionInterface::bodyRegion           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classposition.html">position</a>&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvec3.html">vec3</a>&nbsp;</td>
          <td class="paramname"> <em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="collision_structures_8h.html#0c91a12f5ded514706e730bf7fb60312">Neighborhood</a> *&nbsp;</td>
          <td class="paramname"> <em>neighborhood</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the neighborhood of a given point on the surface of a body. Given the point <em>point</em>, it will find all the vertices of the body that are with <em>radius</em> of this point, as long as they belong to triangles that do not have normals pointing in the opposite direction. This is done in order not to return vertices that are on the other side of a thin body.<p>
Assumes both <em>point</em> and <em>normal</em> are in the coordinate frame of <em>body</em> 
<p>Implemented in <a class="el" href="class_p_q_p_collision.html#fbec2233887a1d2a42967b379ca81648">PQPCollision</a>.</p>

</div>
</div><p>
<a class="anchor" name="74785f85922ade48b3a91520c30dd9c9"></a><!-- doxytag: member="CollisionInterface::bodyToBodyDistance" ref="74785f85922ade48b3a91520c30dd9c9" args="(const Body *body1, const Body *body2, position &amp;p1, position &amp;p2)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double CollisionInterface::bodyToBodyDistance           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>body1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>body2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classposition.html">position</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classposition.html">position</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Distance between two bodies, or -1 if the bodies interpenetrate. On exit, <em>p1</em> and <em>p2</em> are the two points on the bodies that are closest to each other, each in its own body coordinate frame 
<p>Implemented in <a class="el" href="class_p_q_p_collision.html#ee7a6786ea0f40e08cefdc2336736890">PQPCollision</a>.</p>

</div>
</div><p>
<a class="anchor" name="d91750f7b4abf9a93e8f93d642ddfc2a"></a><!-- doxytag: member="CollisionInterface::cloneBody" ref="d91750f7b4abf9a93e8f93d642ddfc2a" args="(Body *clone, const Body *original)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CollisionInterface::cloneBody           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>clone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>original</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a clone of a body that shares the collision geometry hierarchy but has its own transform and can be moved and queried for collision independently. WARNING: there are still problems with the cloning mechanism. If the original is deleted, ot if its collision structures are changed, the lingering clone is almost certain to cause a crash. 
<p>Implemented in <a class="el" href="class_p_q_p_collision.html#7cf4649155f8816ee81bd7a42c6a93b2">PQPCollision</a>.</p>

</div>
</div><p>
<a class="anchor" name="cf32c3f64cc36a9710fa9a25f9cdbabe"></a><!-- doxytag: member="CollisionInterface::compactContactSet" ref="cf32c3f64cc36a9710fa9a25f9cdbabe" args="(ContactReport *contacts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CollisionInterface::compactContactSet           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="collision_structures_8h.html#3dea7f9d0c7c38bbb00ecba267b55a6e">ContactReport</a> *&nbsp;</td>
          <td class="paramname"> <em>contacts</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds all the groups of contacts that have the same normal and replaces them with the contacts on the convex hull of the perimeter that they define. According to theory on contact areas, this has no effect on quality metric computations. 
</div>
</div><p>
<a class="anchor" name="ddf2610315423a5abf7d4af9ce12c13b"></a><!-- doxytag: member="CollisionInterface::contact" ref="ddf2610315423a5abf7d4af9ce12c13b" args="(ContactReport *report, double threshold, const Body *body1, const Body *body2)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int CollisionInterface::contact           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="collision_structures_8h.html#3dea7f9d0c7c38bbb00ecba267b55a6e">ContactReport</a> *&nbsp;</td>
          <td class="paramname"> <em>report</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>body1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>body2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the contacts between two specified bodies 
<p>Implemented in <a class="el" href="class_p_q_p_collision.html#26cea610108b7d4a1277d4ba31b4b275">PQPCollision</a>.</p>

</div>
</div><p>
<a class="anchor" name="e669ef20e964664403c0f41e11919b84"></a><!-- doxytag: member="CollisionInterface::getThreadId" ref="e669ef20e964664403c0f41e11919b84" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CollisionInterface::getThreadId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the id of this thread. The master (original) thread has ID 0. If threads are not used, this will always return 0 
</div>
</div><p>
<a class="anchor" name="35e0791b1846c98a1592b6ac66e9c8d8"></a><!-- doxytag: member="CollisionInterface::isActive" ref="35e0791b1846c98a1592b6ac66e9c8d8" args="(const Body *body1, const Body *body2=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CollisionInterface::isActive           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>body1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>body2</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells us if collisions for a body in general, or a particular pair of bodies, are active. 
<p>
If <em>body2</em> is NULL, it returns whether <em>body1</em> is active in the collision detection system. Otherwise, it returns whether collisions between this particular pair of bodies are active. 
<p>Implemented in <a class="el" href="class_p_q_p_collision.html#7c0a0c197c8f09ae9e0f5e79653fb08b">PQPCollision</a>.</p>

</div>
</div><p>
<a class="anchor" name="c6741d233871c3a2cbb5b8cb1402f423"></a><!-- doxytag: member="CollisionInterface::newThread" ref="c6741d233871c3a2cbb5b8cb1402f423" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CollisionInterface::newThread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Informs the collision detection system that this is now a new thread. All bodies or clones added from now on are specific to this thread. Bodies from a given thread can collide ONLY with bodies from the same thread, or with bodies from the master thread, which has ID 0. 
<p>Reimplemented in <a class="el" href="class_p_q_p_collision.html#75fe5ae379beb69ac665761b2e0c4e93">PQPCollision</a>.</p>

</div>
</div><p>
<a class="anchor" name="372915f17e475dc4007eba4b7fd05b32"></a><!-- doxytag: member="CollisionInterface::pointToBodyDistance" ref="372915f17e475dc4007eba4b7fd05b32" args="(const Body *body1, position point, position &amp;closestPoint, vec3 &amp;closestNormal)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double CollisionInterface::pointToBodyDistance           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>body1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classposition.html">position</a>&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classposition.html">position</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>closestPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvec3.html">vec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>closestNormal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Distance from a point <em>point</em> specified in world <a class="el" href="classcoordinates.html" title="This is the base class for various coordinate representations.">coordinates</a> to a body. On exit, <em>closestPoint</em> is the point on the body that is closest to the given point, and <em>closestNormal</em> is the body normal at that point. Both <em>closestPoint</em> and <em>closestNormal</em> are in world <a class="el" href="classcoordinates.html" title="This is the base class for various coordinate representations.">coordinates</a> 
<p>Implemented in <a class="el" href="class_p_q_p_collision.html#082f9ac91381011c846d3f7d33bbdaa2">PQPCollision</a>.</p>

</div>
</div><p>
<a class="anchor" name="88d63adcec6fecd02c9cd40c8057ecc2"></a><!-- doxytag: member="CollisionInterface::removeContactDuplicates" ref="88d63adcec6fecd02c9cd40c8057ecc2" args="(ContactReport *contacts, double duplicateThreshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CollisionInterface::removeContactDuplicates           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="collision_structures_8h.html#3dea7f9d0c7c38bbb00ecba267b55a6e">ContactReport</a> *&nbsp;</td>
          <td class="paramname"> <em>contacts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>duplicateThreshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all the duplicate contacts from a contact report. 
<p>
Two contacts where both contact points are separated by less than the <em>duplicateThreshold</em> are considered to be the same contact; only on of them is kept. We currently keep the one where the two bodies are closer together.<p>
Do not confuse this duplicateThreshold (usually on the order of millimeters) with the contact threshold (usually 0.1mm).<p>
This is not done when using VCollide, which has a more intelligent method of pruning contacts itself. 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="32f4bf7b4e70031515e3f025ba9ba21f"></a><!-- doxytag: member="CollisionInterface::CONTACT_DUPLICATE_THRESHOLD" ref="32f4bf7b4e70031515e3f025ba9ba21f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="class_collision_interface.html#32f4bf7b4e70031515e3f025ba9ba21f">CollisionInterface::CONTACT_DUPLICATE_THRESHOLD</a> = 3.0<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Two contacts that are separated by less than this are considered the same. 
<p>
Do not confuse this with the contact threshold itself, which is usually on the order of 0.1mm. We generally use this one on the order of 3mm. Arguably, there should be a better spot to define this, maybe where the contact threshold itself is defined as well.<p>
Not all implementations of the collision interface use this. Some do a clever removal of contact duplicates themselves and don't need it. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/src/Collision/<a class="el" href="collision_interface_8h-source.html">collisionInterface.h</a><li>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/src/Collision/collisionInterface.cpp</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jul 24 16:39:10 2009 for Graspit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
