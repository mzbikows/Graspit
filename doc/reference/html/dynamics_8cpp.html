<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Graspit: C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/src/dynamics.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/src/dynamics.cpp File Reference</h1>Implements moveBodies, iterateDynamics, and Lemke's algorithm.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;list&gt;</code><br>
<code>#include &lt;vector&gt;</code><br>
<code>#include &lt;map&gt;</code><br>
<code>#include &lt;algorithm&gt;</code><br>
<code>#include &quot;<a class="el" href="mytools_8h-source.html">mytools.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="dynamics_8h-source.html">dynamics.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="dyn_joint_8h-source.html">dynJoint.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="body_8h-source.html">body.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="robot_8h-source.html">robot.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="contact_8h-source.html">contact.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="world_8h-source.html">world.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="ivmgr_8h-source.html">ivmgr.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="lapack__wrappers_8h-source.html">lapack_wrappers.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="maxdet_8h-source.html">maxdet.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="debug_8h-source.html">debug.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dynamics_8cpp.html#c2e4b572943758d59d5da59778fb348d">myLemke</a> (double *M, int n, double *q, double *z, bool usePrediction, bool ldbg, int &amp;iterations)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="52ea780eb1402d7639a538babf306cc5"></a><!-- doxytag: member="dynamics.cpp::buildJointConstraints" ref="52ea780eb1402d7639a538babf306cc5" args="(std::vector&lt; Robot * &gt; &amp;robotVec, std::vector&lt; int &gt; &amp;islandIndices, int numBodies, double *Nu, double *eps, double *H, double *g, double h)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>buildJointConstraints</b> (std::vector&lt; <a class="el" href="class_robot.html">Robot</a> * &gt; &amp;robotVec, std::vector&lt; int &gt; &amp;islandIndices, int numBodies, double *Nu, double *eps, double *H, double *g, double h)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dynamics_8cpp.html#84a3e8ac05c67f044eb1c0f9ef8d7480">assembleLCPPrediction</a> (double *lambda, int Arows, int numDOFLimits, std::list&lt; <a class="el" href="class_contact.html">Contact</a> * &gt; *contactList)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f558dc83f7f95c2b973bece83d624057"></a><!-- doxytag: member="dynamics.cpp::printLCPBasis" ref="f558dc83f7f95c2b973bece83d624057" args="(double *lambda, int Arows, int numDOFLimits, int numContacts)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>printLCPBasis</b> (double *lambda, int Arows, int numDOFLimits, int numContacts)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dynamics_8cpp.html#c3c1f23fca87a4fab6d405d138933ad6">fillMatrixBlock</a> (double *B, int ldb, int r1, int c1, int r2, int c2, double *M, int ldm)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dynamics_8cpp.html#07496ba94193709ecd5b095f44cb071d">buildForceTransform</a> (<a class="el" href="classtransf.html">transf</a> &amp;T, <a class="el" href="classvec3.html">vec3</a> &amp;p, double *transformMat)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dynamics_8cpp.html#2a9e1efcba88d46dfa9b6cef2e655a14">invertMatrix</a> (int n, double *A, double *INVA)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dynamics_8cpp.html#95dbedd97ede52c0f1fec10e99f2e704">moveBodies</a> (int numBodies, std::vector&lt; <a class="el" href="class_dynamic_body.html">DynamicBody</a> * &gt; bodyVec, double h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves all dynamic bodies for one time step.  <a href="#95dbedd97ede52c0f1fec10e99f2e704"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="dynamics_8cpp.html#1fba7991ba96c0c2231de412256321cd">iterateDynamics</a> (std::vector&lt; <a class="el" href="class_robot.html">Robot</a> * &gt; robotVec, std::vector&lt; <a class="el" href="class_dynamic_body.html">DynamicBody</a> * &gt; bodyVec, DynamicParameters *dp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the new velocites of all bodies, based on contact and joint constraints.  <a href="#1fba7991ba96c0c2231de412256321cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dae5dc62aea6e6c572198db84153ffde"></a><!-- doxytag: member="dynamics.cpp::sortVector" ref="dae5dc62aea6e6c572198db84153ffde" args="(int *v, int n)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sortVector</b> (int *v, int n)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e728b88f4032a02ee46e75ab479b927d"></a><!-- doxytag: member="dynamics.cpp::debugfile" ref="e728b88f4032a02ee46e75ab479b927d" args="" -->
FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><b>debugfile</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9f4946f3262ff44ad6a51621adaa78d"></a><!-- doxytag: member="dynamics.cpp::ivmgr" ref="e9f4946f3262ff44ad6a51621adaa78d" args="" -->
<a class="el" href="class_i_vmgr.html">IVmgr</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ivmgr</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Implements moveBodies, iterateDynamics, and Lemke's algorithm. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="84a3e8ac05c67f044eb1c0f9ef8d7480"></a><!-- doxytag: member="dynamics.cpp::assembleLCPPrediction" ref="84a3e8ac05c67f044eb1c0f9ef8d7480" args="(double *lambda, int Arows, int numDOFLimits, std::list&lt; Contact * &gt; *contactList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void assembleLCPPrediction           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Arows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numDOFLimits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; <a class="el" href="class_contact.html">Contact</a> * &gt; *&nbsp;</td>
          <td class="paramname"> <em>contactList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to use information from the solution at the previous time step, stored in each contact, to bootstrap the LCP at the current step. In theory, this could help a lot and all the framework is here, we just never got it to actually do much. 
</div>
</div><p>
<a class="anchor" name="07496ba94193709ecd5b095f44cb071d"></a><!-- doxytag: member="dynamics.cpp::buildForceTransform" ref="07496ba94193709ecd5b095f44cb071d" args="(transf &amp;T, vec3 &amp;p, double *transformMat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buildForceTransform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtransf.html">transf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvec3.html">vec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>transformMat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a 6x6 matrix, <em>transformMat</em>, that transforms a wrench expressed in one coordinate system to wrench expressed in another. <em>T</em> is the transform, and <em>p</em> is the new torque origin expressed within the new coordinate system. 
</div>
</div><p>
<a class="anchor" name="c3c1f23fca87a4fab6d405d138933ad6"></a><!-- doxytag: member="dynamics.cpp::fillMatrixBlock" ref="c3c1f23fca87a4fab6d405d138933ad6" args="(double *B, int ldb, int r1, int c1, int r2, int c2, double *M, int ldm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fillMatrixBlock           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ldm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies matrix <em>B</em> into a block of matrix <em>M</em>. <em>ldb</em> is the number of rows of <em>B</em>, <em>r1</em> and <em>r2</em> are the start and end rows within <em>M</em>, and <em>c1</em> and <em>c2</em> are the start and end columns in <em>M</em>. <em>ldm</em> is the number of rows in <em>M</em>. 
</div>
</div><p>
<a class="anchor" name="2a9e1efcba88d46dfa9b6cef2e655a14"></a><!-- doxytag: member="dynamics.cpp::invertMatrix" ref="2a9e1efcba88d46dfa9b6cef2e655a14" args="(int n, double *A, double *INVA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int invertMatrix           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>INVA</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inverts an n by n matrix. 
</div>
</div><p>
<a class="anchor" name="1fba7991ba96c0c2231de412256321cd"></a><!-- doxytag: member="dynamics.cpp::iterateDynamics" ref="1fba7991ba96c0c2231de412256321cd" args="(std::vector&lt; Robot * &gt; robotVec, std::vector&lt; DynamicBody * &gt; bodyVec, DynamicParameters *dp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iterateDynamics           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_robot.html">Robot</a> * &gt;&nbsp;</td>
          <td class="paramname"> <em>robotVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_dynamic_body.html">DynamicBody</a> * &gt;&nbsp;</td>
          <td class="paramname"> <em>bodyVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicParameters *&nbsp;</td>
          <td class="paramname"> <em>dp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the new velocites of all bodies, based on contact and joint constraints. 
<p>
This routine builds a Linear Complementarity Problem (LCP) to solve for the velocities of each dynamic body in a given island of connected dynamic bodies (connected by joints or contacts). The robots and bodies in the island are passed to the routine in the vectors <em>robotVec</em> and <em>bodyVec</em>, and the integration time step <em>h</em> is also provided. The <em>useContactEps</em> flag determines whether error correction will be used for the contacts to ensure non-interpenetration. At the end of the routine, the velocity of each body is updated, as well as all contact and joint forces. 
</div>
</div><p>
<a class="anchor" name="95dbedd97ede52c0f1fec10e99f2e704"></a><!-- doxytag: member="dynamics.cpp::moveBodies" ref="95dbedd97ede52c0f1fec10e99f2e704" args="(int numBodies, std::vector&lt; DynamicBody * &gt; bodyVec, double h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int moveBodies           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_dynamic_body.html">DynamicBody</a> * &gt;&nbsp;</td>
          <td class="paramname"> <em>bodyVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves all dynamic bodies for one time step. 
<p>
Given a vector of pointers to dynamic bodies, and the number of bodies in the vector, this routine will move those bodies in the direction of their current velocity for the length of the timestep, <em>h</em>. It uses the pre-computed velocities and accelerations computed by iterateDynamics and stored for each body. 
</div>
</div><p>
<a class="anchor" name="c2e4b572943758d59d5da59778fb348d"></a><!-- doxytag: member="dynamics.cpp::myLemke" ref="c2e4b572943758d59d5da59778fb348d" args="(double *M, int n, double *q, double *z, bool usePrediction, bool ldbg, int &amp;iterations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int myLemke           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>usePrediction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ldbg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>iterations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implementation of Lemke's algorithm for solving pure LCP's. <em>M</em> and <em>q</em> are the matrix and vector that define the LCP. <em>n</em> is the number of rows in <em>M</em> and <em>q</em>, and <em>z</em> is the result. <em>usePrediction</em> is a flag that tells the algorithm to use as a starting basis the initial value of <em>z</em>. If it is set to false, the initial value of <em>z</em> is ignored. <em>ldbg</em> is a debug flag. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jul 24 16:39:09 2009 for Graspit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
