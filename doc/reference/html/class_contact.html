<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Graspit: Contact Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Contact Class Reference</h1><!-- doxytag: class="Contact" -->A contact between 2 bodies.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="contact_8h-source.html">contact.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Contact:</div>
<div class="dynsection">

<p><center><img src="class_contact.png" usemap="#Contact_map" border="0" alt=""></center>
<map name="Contact_map">
<area href="class_point_contact.html" alt="PointContact" shape="rect" coords="0,56,92,80">
<area href="class_soft_contact.html" alt="SoftContact" shape="rect" coords="102,56,194,80">
<area href="class_virtual_contact.html" alt="VirtualContact" shape="rect" coords="204,56,296,80">
</map>
</div>

<p>
<a href="class_contact-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e39444f378e6de7fd6c3e60981949af5"></a><!-- doxytag: member="Contact::Contact" ref="e39444f378e6de7fd6c3e60981949af5" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#e39444f378e6de7fd6c3e60981949af5">Contact</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes an empty contact (not really used). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#28d525a0534784e1adc356a4a141e426">Contact</a> (<a class="el" href="class_body.html">Body</a> *b1, <a class="el" href="class_body.html">Body</a> *b2, <a class="el" href="classposition.html">position</a> pos, <a class="el" href="classvec3.html">vec3</a> norm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a contact between two bodies.  <a href="#28d525a0534784e1adc356a4a141e426"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#b68013cc59e3d640735c573e52c35219">~Contact</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#b68013cc59e3d640735c573e52c35219"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#6bc3e2e946d690fe20f07a8d28351e99">computeWrenches</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pure friction edges into full contact wrenches by considering normal force.  <a href="#6bc3e2e946d690fe20f07a8d28351e99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e085d4353611be7735dbbcb7f2074050"></a><!-- doxytag: member="Contact::setUpFrictionEdges" ref="e085d4353611be7735dbbcb7f2074050" args="(bool dynamicsOn=false)=0" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#e085d4353611be7735dbbcb7f2074050">setUpFrictionEdges</a> (bool dynamicsOn=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Main function for defining the space of friction that can be applied at this contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#6de167eb9535347be600d2f8d4c75de3">setMate</a> (<a class="el" href="class_contact.html">Contact</a> *m)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classposition.html">position</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#23a161cf61a4c5d92c18451f822bcf7f">getPosition</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classvec3.html">vec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#d2e3e9d840a97e44c235259bcbcfc60e">getNormal</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_contact.html">Contact</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#ac5415b56e2843de36a3d96c2eddb50b">getMate</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_body.html">Body</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#1b8ce0502c46e93eb9510a6e4659ad59">getBody1</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_body.html">Body</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#6da397ae10d3138fe3287a466b01e261">getBody2</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classtransf.html">transf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#4373b26cc2fa67b1b7b28175e45fb3af">getBody1Tran</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classtransf.html">transf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#a8468368ac9b7eff1da863d312c5d6b2">getBody2Tran</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#d408ca39376bfbf099adc4bf295f6cd5">getCof</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the coefficient of friction for this contact.  <a href="#d408ca39376bfbf099adc4bf295f6cd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f2ace2dba108d42f92e988e3936dccd1"></a><!-- doxytag: member="Contact::getLocation" ref="f2ace2dba108d42f92e988e3936dccd1" args="() const " -->
<a class="el" href="classposition.html">position</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#f2ace2dba108d42f92e988e3936dccd1">getLocation</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the location. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5c7c1cf5a500e3287506ae5f72600fe"></a><!-- doxytag: member="Contact::getFrame" ref="a5c7c1cf5a500e3287506ae5f72600fe" args="() const " -->
<a class="el" href="classtransf.html">transf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#a5c7c1cf5a500e3287506ae5f72600fe">getFrame</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#cfebdb8da1152081ad31956431131020">updateCof</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates the coefficient of friction (called when the body materials have changed).  <a href="#cfebdb8da1152081ad31956431131020"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="contact_8h.html#38dd70084d5973b5981fa757c61e4181">frictionT</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#38d82d8c85add02c9d83afab804df4b3">getFrictionType</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classtransf.html">transf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#af757601e743d7fc01027440ed8cfcaa">getContactFrame</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#78032db0e33df225ad3d833e474af48a">getDynamicContactWrench</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SoSeparator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#7f872f6ae2ff4e6802359fa8c9a00dc6">getContactForcePointers</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#75bd54874aef48f9c230fb9d729260f6">preventsMotion</a> (const <a class="el" href="classtransf.html">transf</a> &amp;motion) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#9a488e945014def078175a3b7a2cb850">setContactForce</a> (double *optmx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by GFO routine to set optimal contact force.  <a href="#9a488e945014def078175a3b7a2cb850"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#2199cd254732a570550ba45cab721ebd">getContactDim</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#e7798c39957d9d342ad2e56107b757ad">getLmiDim</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#c0ba86f43094c7120fda2fd6a4558b21">setNormalForceLimit</a> (double nfl)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#ef30f9d47fb3a16e5d75a2782cef8ef0">getNormalForceLimit</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#7bb61eeb23af511eb566ed5d72b28eb5">frictionConstraintsMatrix</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a matrix for friction constraints at this contact that can be used in an LCP.  <a href="#7bb61eeb23af511eb566ed5d72b28eb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#b328b828bc517aeaec4430a2ca4f0e60">frictionForceMatrix</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the matrix that relates friction edge amplitudes to normal and frictional force.  <a href="#b328b828bc517aeaec4430a2ca4f0e60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#b945418512d75486f769e603a63ba36e">localToWorldWrenchMatrix</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the matrix that transforms a force on this contact into a wrench on the other body.  <a href="#b945418512d75486f769e603a63ba36e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#62ae8ba2aba22af4f61dccad1f67307f">setDynamicContactWrench</a> (double f[6])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#7caca6e73c8e8a9b27be7c5de9e34a69">setDynamicContactForce</a> (const <a class="el" href="classvec3.html">vec3</a> &amp;force)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#b9d5f0e1c11b51c9894ea3250cf34497">inherit</a> (<a class="el" href="class_contact.html">Contact</a> *c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#126b6d2c37136bd4e28adb70a7a0b481">getConstraintError</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The error that shows that this contact constraints are violated during dynamic simulation.  <a href="#126b6d2c37136bd4e28adb70a7a0b481"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bbdee174f7e9db2cac9369c5e09968db"></a><!-- doxytag: member="Contact::getVisualIndicator" ref="bbdee174f7e9db2cac9369c5e09968db" args="()" -->
virtual SoSeparator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#bbdee174f7e9db2cac9369c5e09968db">getVisualIndicator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the IV root of the visual markers that shows the location of this contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f8dda13fbd4b484c800bfce01017ae0a"></a><!-- doxytag: member="Contact::getPrevCn" ref="f8dda13fbd4b484c800bfce01017ae0a" args="()" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#f8dda13fbd4b484c800bfce01017ae0a">getPrevCn</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get dynamic sovler LCP information from the previous time step. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b4e9124c97c7530eec3e35010e2e539"></a><!-- doxytag: member="Contact::getPrevLambda" ref="5b4e9124c97c7530eec3e35010e2e539" args="()" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#5b4e9124c97c7530eec3e35010e2e539">getPrevLambda</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get dynamic sovler LCP information from the previous time step. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fb88dc87dbc66faf6cfa55619423fd91"></a><!-- doxytag: member="Contact::getPrevBetas" ref="fb88dc87dbc66faf6cfa55619423fd91" args="()" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#fb88dc87dbc66faf6cfa55619423fd91">getPrevBetas</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get dynamic sovler LCP information from the previous time step. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="487d51fe9660256fc1df1a47c50754d5"></a><!-- doxytag: member="Contact::setLCPInfo" ref="487d51fe9660256fc1df1a47c50754d5" args="(double cn, double l, double *betas)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#487d51fe9660256fc1df1a47c50754d5">setLCPInfo</a> (double cn, double l, double *betas)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set dynamic sovler LCP information which might be used at the next time step. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9fdee0e707dad47b0509fa913e4f7208"></a><!-- doxytag: member="Contact::isSlipping" ref="9fdee0e707dad47b0509fa913e4f7208" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#9fdee0e707dad47b0509fa913e4f7208">isSlipping</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the slip flag which does not work very well. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="59850a2335601efc4988bdfad299226d"></a><!-- doxytag: member="Contact::inherits" ref="59850a2335601efc4988bdfad299226d" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#59850a2335601efc4988bdfad299226d">inherits</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells us if this contact has inherited some information from previous time step. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#54636acbf6d00047cce40060c266913d">frictionConstraintsBlockMatrix</a> (const std::list&lt; <a class="el" href="class_contact.html">Contact</a> * &gt; &amp;contacts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a block matrix composed of individual constraint matrices for the contacts in the list.  <a href="#54636acbf6d00047cce40060c266913d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#e1d3cd3d076e86119e0dae5f016e8710">frictionForceBlockMatrix</a> (const std::list&lt; <a class="el" href="class_contact.html">Contact</a> * &gt; &amp;contacts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a block matrix made up of individual force matrices from the contacts in the list.  <a href="#e1d3cd3d076e86119e0dae5f016e8710"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#d6dc61692e05b50493dbde17eaacb164">localToWorldWrenchBlockMatrix</a> (const std::list&lt; <a class="el" href="class_contact.html">Contact</a> * &gt; &amp;contacts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a block matrix made up of individual force to world wrench conversion matrices.  <a href="#d6dc61692e05b50493dbde17eaacb164"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#5bbf145e91ae467b8162b06794c5ebd5">normalForceSumMatrix</a> (const std::list&lt; <a class="el" href="class_contact.html">Contact</a> * &gt; &amp;contacts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a matrix that adds just the normal force components of an amplitudes vector.  <a href="#5bbf145e91ae467b8162b06794c5ebd5"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#ce3fec393adedbba95141f81ff4c4ef5">frictionEdges</a> [6 *MAX_FRICTION_EDGES]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">6 x numFrictionEdges matrix of friction cone boundary wrenches used in dynmaics  <a href="#ce3fec393adedbba95141f81ff4c4ef5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="58d7afd8f565883d05907b6cbb20b463"></a><!-- doxytag: member="Contact::numFrictionEdges" ref="58d7afd8f565883d05907b6cbb20b463" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#58d7afd8f565883d05907b6cbb20b463">numFrictionEdges</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of friction edges defining the frictional component of contact wrenches <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_wrench.html">Wrench</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#f65bf1f224046c5ba137f2a4c5f1e138">wrench</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of wrenches bounding the <a class="el" href="class_contact.html" title="A contact between 2 bodies.">Contact</a> <a class="el" href="struct_wrench.html" title="A wrench is a 6-vector containing 2 3-vectors for the force and torque components...">Wrench</a> Space (CWS).  <a href="#f65bf1f224046c5ba137f2a4c5f1e138"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="acde288d4088d00a2cbca9fb9356bc73"></a><!-- doxytag: member="Contact::numFCWrenches" ref="acde288d4088d00a2cbca9fb9356bc73" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#acde288d4088d00a2cbca9fb9356bc73">numFCWrenches</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of total friction wrenches. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2440b99c785c4365f2976711a2d053f2"></a><!-- doxytag: member="Contact::coneMat" ref="2440b99c785c4365f2976711a2d053f2" args="" -->
SoMaterial *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#2440b99c785c4365f2976711a2d053f2">coneMat</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A debug tool to see that contact inheritance works right. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="23a7777a2b77585dcc71c452e904248b"></a><!-- doxytag: member="Contact::coneR" ref="23a7777a2b77585dcc71c452e904248b" args="" -->
float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#23a7777a2b77585dcc71c452e904248b">coneR</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A debug tool to see that contact inheritance works right. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0b30d9f7b6a318af6828a7fe048e3f7a"></a><!-- doxytag: member="Contact::coneG" ref="0b30d9f7b6a318af6828a7fe048e3f7a" args="" -->
float&nbsp;</td><td class="memItemRight" valign="bottom"><b>coneG</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="df33291e78610d65ae31eb6e481014c6"></a><!-- doxytag: member="Contact::coneB" ref="df33291e78610d65ae31eb6e481014c6" args="" -->
float&nbsp;</td><td class="memItemRight" valign="bottom"><b>coneB</b></td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9702d09de3a0153fcd643566fa6ade5"></a><!-- doxytag: member="Contact::THRESHOLD" ref="a9702d09de3a0153fcd643566fa6ade5" args="" -->
static const double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#a9702d09de3a0153fcd643566fa6ade5">THRESHOLD</a> = 0.1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum separation distance (in mm) between two bodies that are considered to be in contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1c7654b81fb16f5bb05b685c36c300c1"></a><!-- doxytag: member="Contact::INHERITANCE_THRESHOLD" ref="1c7654b81fb16f5bb05b685c36c300c1" args="" -->
static const double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#1c7654b81fb16f5bb05b685c36c300c1">INHERITANCE_THRESHOLD</a> = 1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum linear distance for which two contacts at consecutive time steps are considered to be the same contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d08296995ebddd9ecf6384038ab76b01"></a><!-- doxytag: member="Contact::INHERITANCE_ANGULAR_THRESHOLD" ref="d08296995ebddd9ecf6384038ab76b01" args="" -->
static const double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#d08296995ebddd9ecf6384038ab76b01">INHERITANCE_ANGULAR_THRESHOLD</a> = 0.984</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum angular distance for which two contacts at consecutive time steps are considered to be the same contact. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#14886fe15e02a4eb13b2865185c21e9b">wrenchFromFrictionEdge</a> (double *edge, const <a class="el" href="classvec3.html">vec3</a> &amp;radius, <a class="el" href="struct_wrench.html">Wrench</a> *wr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes a single contact wrench from a friction edge  <a href="#14886fe15e02a4eb13b2865185c21e9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#4536b5d28a5cb2220bd231c160540e1a">setUpFrictionEllipsoid</a> (int numLatitudes, int numDirs[], double phi[], double eccen[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up frictional forces at this contact using a linearized ellipsoid.  <a href="#4536b5d28a5cb2220bd231c160540e1a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cd16f3dde844213883eee52bfb6b4f7f"></a><!-- doxytag: member="Contact::body1" ref="cd16f3dde844213883eee52bfb6b4f7f" args="" -->
<a class="el" href="class_body.html">Body</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#cd16f3dde844213883eee52bfb6b4f7f">body1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the body this contact is on. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="be9b5de08f306afa57e79e2d7886ac2e"></a><!-- doxytag: member="Contact::body2" ref="be9b5de08f306afa57e79e2d7886ac2e" args="" -->
<a class="el" href="class_body.html">Body</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#be9b5de08f306afa57e79e2d7886ac2e">body2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the other body involved in this contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9c75e5737b0e2b2e53c11b0e09391447"></a><!-- doxytag: member="Contact::mate" ref="9c75e5737b0e2b2e53c11b0e09391447" args="" -->
<a class="el" href="class_contact.html">Contact</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#9c75e5737b0e2b2e53c11b0e09391447">mate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Points to the other contact in this pair. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6561aeb5b959ffde6d452e7853ec1e9c"></a><!-- doxytag: member="Contact::cof" ref="6561aeb5b959ffde6d452e7853ec1e9c" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#6561aeb5b959ffde6d452e7853ec1e9c">cof</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coefficient of static friction. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2ea4e597578e7cd29d30fce99e0ae076"></a><!-- doxytag: member="Contact::kcof" ref="2ea4e597578e7cd29d30fce99e0ae076" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#2ea4e597578e7cd29d30fce99e0ae076">kcof</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coefficient of kinetic friction. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5f4cc4add2b0eb9f9593e232922a873b"></a><!-- doxytag: member="Contact::frictionType" ref="5f4cc4add2b0eb9f9593e232922a873b" args="" -->
<a class="el" href="contact_8h.html#38dd70084d5973b5981fa757c61e4181">frictionT</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#5f4cc4add2b0eb9f9593e232922a873b">frictionType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of friction model at this contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0875769df08c2dc2785221280a19d4c5"></a><!-- doxytag: member="Contact::contactDim" ref="0875769df08c2dc2785221280a19d4c5" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#0875769df08c2dc2785221280a19d4c5">contactDim</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_contact.html" title="A contact between 2 bodies.">Contact</a> dimension (num basisvecs): 1 for FL, 3 for PCWF, 4 for SFCE, 4 for SFCL. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f482346620ed1c5893f7d842880b6e27"></a><!-- doxytag: member="Contact::lmiDim" ref="f482346620ed1c5893f7d842880b6e27" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#f482346620ed1c5893f7d842880b6e27">lmiDim</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LMI dimension: 1 for FL, 3 for PCWF, 4 for SFCE, 7 for SFCL. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b41707d2677862e04d5caadcc4ea8df2"></a><!-- doxytag: member="Contact::loc" ref="b41707d2677862e04d5caadcc4ea8df2" args="" -->
<a class="el" href="classposition.html">position</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#b41707d2677862e04d5caadcc4ea8df2">loc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coordinates of the contact with respect to body 1 base frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1f9c92d713010a4d6c7bce2ae56dd4ed"></a><!-- doxytag: member="Contact::normal" ref="1f9c92d713010a4d6c7bce2ae56dd4ed" args="" -->
<a class="el" href="classvec3.html">vec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#1f9c92d713010a4d6c7bce2ae56dd4ed">normal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_contact.html" title="A contact between 2 bodies.">Contact</a> normal with respect to body 1 base frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2a95e3030f7ac0d99580ec988adbfbe3"></a><!-- doxytag: member="Contact::frame" ref="2a95e3030f7ac0d99580ec988adbfbe3" args="" -->
<a class="el" href="classtransf.html">transf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#2a95e3030f7ac0d99580ec988adbfbe3">frame</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pose of the contact frame with respect to the body1 frame. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ac202a725e576576f222eb7fae970c30"></a><!-- doxytag: member="Contact::body1Tran" ref="ac202a725e576576f222eb7fae970c30" args="" -->
<a class="el" href="classtransf.html">transf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#ac202a725e576576f222eb7fae970c30">body1Tran</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pose of body 1 in world space at time of contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ca78689013ccb9ee8f1e37b0090aa466"></a><!-- doxytag: member="Contact::body2Tran" ref="ca78689013ccb9ee8f1e37b0090aa466" args="" -->
<a class="el" href="classtransf.html">transf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#ca78689013ccb9ee8f1e37b0090aa466">body2Tran</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pose of body 2 in world space at time of contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f7cd0d71ad945e524f619c7a51ee99e5"></a><!-- doxytag: member="Contact::contactForcePointers" ref="f7cd0d71ad945e524f619c7a51ee99e5" args="" -->
SoSeparator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#f7cd0d71ad945e524f619c7a51ee99e5">contactForcePointers</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Root Inventor node stores arrow geometry representing current contact force. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="87f56ab7bbff851119aa388316e41204"></a><!-- doxytag: member="Contact::normalForceLimit" ref="87f56ab7bbff851119aa388316e41204" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#87f56ab7bbff851119aa388316e41204">normalForceLimit</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum normal force for this contact point due to hand torque limits. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="733ef000391ac8074b1f90eeee7dcffc"></a><!-- doxytag: member="Contact::optimalCoeffs" ref="733ef000391ac8074b1f90eeee7dcffc" args="" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#733ef000391ac8074b1f90eeee7dcffc">optimalCoeffs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A contactDim vector containing the optimal values to multiply with basisVecs. This will produce the contact forces necessary to generate the needed object wrench. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b92c293ec98320913c18259e961ac371"></a><!-- doxytag: member="Contact::dynamicForce" ref="b92c293ec98320913c18259e961ac371" args="[6]" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#b92c293ec98320913c18259e961ac371">dynamicForce</a> [6]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current dynamic force acting at this contact. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0b02303835be7712e0ea8d14daa6fc86"></a><!-- doxytag: member="Contact::prevCn" ref="0b02303835be7712e0ea8d14daa6fc86" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#0b02303835be7712e0ea8d14daa6fc86">prevCn</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamics LCP information from the previous time step;. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="39bf0a6beeea2faa77d4eff7bbab4850"></a><!-- doxytag: member="Contact::prevLambda" ref="39bf0a6beeea2faa77d4eff7bbab4850" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#39bf0a6beeea2faa77d4eff7bbab4850">prevLambda</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamics LCP information from the previous time step;. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="782dced4f6d026fe6f75809ca867388f"></a><!-- doxytag: member="Contact::prevBetas" ref="782dced4f6d026fe6f75809ca867388f" args="" -->
double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#782dced4f6d026fe6f75809ca867388f">prevBetas</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamics LCP information from the previous time step;. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="90a00e0a86e2ccd43698683531ea3158"></a><!-- doxytag: member="Contact::inheritanceInfo" ref="90a00e0a86e2ccd43698683531ea3158" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#90a00e0a86e2ccd43698683531ea3158">inheritanceInfo</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells us wether this contact has inherited some information from the previous dynamic time step. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4c468f8a27d8f56cf6bccee1f76ea063"></a><!-- doxytag: member="Contact::mSlip" ref="4c468f8a27d8f56cf6bccee1f76ea063" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#4c468f8a27d8f56cf6bccee1f76ea063">mSlip</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Based on LCP solution, this flag shows if the contact is slipping or not. Does not work well. <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d39645e656e7539a2f25ad781f7a4e8"></a><!-- doxytag: member="Contact::VirtualContact" ref="6d39645e656e7539a2f25ad781f7a4e8" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_contact.html#6d39645e656e7539a2f25ad781f7a4e8">VirtualContact</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A contact between 2 bodies. 
<p>
Contacts always come in pairs. When two bodies touch, a contact is defined for each of them. They have the same (or very close to the same) global positions, opposite inward pointing normals, and share the same coefficients of friction. Any instance of this class will have as mate its reciprocal contact on the other body.<p>
A contact is defined in places where two bodies are separated by less then the contact threshold (usually set to 0.1 mm). In GraspIt, two bodies are NEVER allowed to interpenetrate; they are considered in contact if they are apart, but separated by less than the threshold.<p>
We always define contacts to occur precisely at a point (as opposed to a small area). This makes computations much easier, as we don't have to compute deformations. The <a class="el" href="class_grasp.html" title="A grasp occurs between a hand and an object and has quality measures associated with...">Grasp</a> class will however consider the case of objects that match geometry so that many point contacts can occur on the same patch. For soft bodies, we have the <a class="el" href="class_soft_contact.html" title="Soft Contact implements an SFC model for contacts between soft bodies.">SoftContact</a> class which inherits from this one and tries to approximate the frictional effects of having a contact patch (while not computing such a patch explicitly).<p>
Contacts also define their own linearized friction models. This means that, for each contact, friction is constrained to lie within some convex polyhedron. The edges that define this polyhedron are different for different types of contacts, which inherit from this class. However, once the edges of the friction polyhedron are defined, all contact behave identically.<p>
You will also find here code for two projects which are not used right now. The first one if <a class="el" href="class_grasp.html" title="A grasp occurs between a hand and an object and has quality measures associated with...">Grasp</a> Force Optimization (GFO). See the grasp class for that code; it is finished but has never been tested. Also, the GFO code has never been updated to work with the new <a class="el" href="class_contact.html" title="A contact between 2 bodies.">Contact</a> hierarchy of <a class="el" href="class_point_contact.html" title="A Point Contact With Friction (PCWF) implementing a Coulomb friction model.">PointContact</a>, <a class="el" href="class_soft_contact.html" title="Soft Contact implements an SFC model for contacts between soft bodies.">SoftContact</a> etc, and uses a parallel mechanism to keep track of friction models. The second one concerns the dynamics engine: in theory, we can try to save contact information from a time step to help the solver during the next time step. The framework is in place, but we have never used it. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="28d525a0534784e1adc356a4a141e426"></a><!-- doxytag: member="Contact::Contact" ref="28d525a0534784e1adc356a4a141e426" args="(Body *b1, Body *b2, position pos, vec3 norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Contact::Contact           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_body.html">Body</a> *&nbsp;</td>
          <td class="paramname"> <em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classposition.html">position</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvec3.html">vec3</a>&nbsp;</td>
          <td class="paramname"> <em>norm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a contact between two bodies. 
<p>
Initializes a new contact on body <em>b1</em>. The other contacting body is <em>b2</em>. The contact <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> <em>pos</em> and the contact normal <em>norm</em> are expressed in local body <em>b1</em> <a class="el" href="classcoordinates.html" title="This is the base class for various coordinate representations.">coordinates</a>. 
</div>
</div><p>
<a class="anchor" name="b68013cc59e3d640735c573e52c35219"></a><!-- doxytag: member="Contact::~Contact" ref="b68013cc59e3d640735c573e52c35219" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Contact::~Contact           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Deletes contact basis vectors, optimal force coefficients, and friction cone boundary wrenches. If the contact has an undeleted mate, it removes the mate's connection to this contact, and removes the mate contact from the other body (thus deleting it). 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6bc3e2e946d690fe20f07a8d28351e99"></a><!-- doxytag: member="Contact::computeWrenches" ref="6bc3e2e946d690fe20f07a8d28351e99" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contact::computeWrenches           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts pure friction edges into full contact wrenches by considering normal force. 
<p>
Takes the information about pure friction at this contact, contained in the frictionEdges, and adds normal force and the effect of coeff of friction to obtain actual wrenches that can be applied at this contact. Essentially builds the <a class="el" href="class_contact.html" title="A contact between 2 bodies.">Contact</a> <a class="el" href="struct_wrench.html" title="A wrench is a 6-vector containing 2 3-vectors for the force and torque components...">Wrench</a> Space based on the friction information and (normalized) contact forces. See wrenchFromFrictionEdge for details. 
<p>Reimplemented in <a class="el" href="class_soft_contact.html#0fcc06820d2c8ad1900cf0c4f0ac70d8">SoftContact</a>.</p>

</div>
</div><p>
<a class="anchor" name="54636acbf6d00047cce40060c266913d"></a><!-- doxytag: member="Contact::frictionConstraintsBlockMatrix" ref="54636acbf6d00047cce40060c266913d" args="(const std::list&lt; Contact * &gt; &amp;contacts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Contact::frictionConstraintsBlockMatrix           </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; <a class="el" href="class_contact.html">Contact</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>contacts</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a block matrix composed of individual constraint matrices for the contacts in the list. 
<p>
Creates the friction constraint matrices of all contacts in the list using Contact::frictionConstraintMatrix(), then assembles all the matrices in block diagonal form. 
</div>
</div><p>
<a class="anchor" name="7bb61eeb23af511eb566ed5d72b28eb5"></a><!-- doxytag: member="Contact::frictionConstraintsMatrix" ref="7bb61eeb23af511eb566ed5d72b28eb5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Contact::frictionConstraintsMatrix           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a matrix for friction constraints at this contact that can be used in an LCP. 
<p>
Assembles a friction constraint matrix for this contact that can be used in an LCP. This matrix is of the form [-mu 1 1 ... 1] with a 1 for each friction edge. This is used in a constraint as F * beta &lt;= 0, saying that the sum of friction edge amplitudes (thus friction force) must be less than normal force times friction coefficient. 
</div>
</div><p>
<a class="anchor" name="e1d3cd3d076e86119e0dae5f016e8710"></a><!-- doxytag: member="Contact::frictionForceBlockMatrix" ref="e1d3cd3d076e86119e0dae5f016e8710" args="(const std::list&lt; Contact * &gt; &amp;contacts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Contact::frictionForceBlockMatrix           </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; <a class="el" href="class_contact.html">Contact</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>contacts</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a block matrix made up of individual force matrices from the contacts in the list. 
<p>
Creates the individual force matrices for all contacts in the list using frictionConstraintMatrix() then assembles them in block diagonal form. 
</div>
</div><p>
<a class="anchor" name="b328b828bc517aeaec4430a2ca4f0e60"></a><!-- doxytag: member="Contact::frictionForceMatrix" ref="b328b828bc517aeaec4430a2ca4f0e60" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Contact::frictionForceMatrix           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the matrix that relates friction edge amplitudes to normal and frictional force. 
<p>
Returns the matric that relates friction edge amplitudes to friction force. That matrix is of the form [n D] where n is the contact normal and D has as columns the friction edges. The computations are done in local contact coordinate system (contact normal along the z axis). 
</div>
</div><p>
<a class="anchor" name="1b8ce0502c46e93eb9510a6e4659ad59"></a><!-- doxytag: member="Contact::getBody1" ref="1b8ce0502c46e93eb9510a6e4659ad59" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_body.html">Body</a>* Contact::getBody1           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to body this contact is on. 
</div>
</div><p>
<a class="anchor" name="4373b26cc2fa67b1b7b28175e45fb3af"></a><!-- doxytag: member="Contact::getBody1Tran" ref="4373b26cc2fa67b1b7b28175e45fb3af" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtransf.html">transf</a> Contact::getBody1Tran           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the pose of body1 when this contact was formed. 
</div>
</div><p>
<a class="anchor" name="6da397ae10d3138fe3287a466b01e261"></a><!-- doxytag: member="Contact::getBody2" ref="6da397ae10d3138fe3287a466b01e261" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_body.html">Body</a>* Contact::getBody2           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the other body invovled in this contact. 
</div>
</div><p>
<a class="anchor" name="a8468368ac9b7eff1da863d312c5d6b2"></a><!-- doxytag: member="Contact::getBody2Tran" ref="a8468368ac9b7eff1da863d312c5d6b2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtransf.html">transf</a> Contact::getBody2Tran           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the pose of body2 when this contact was formed. 
</div>
</div><p>
<a class="anchor" name="d408ca39376bfbf099adc4bf295f6cd5"></a><!-- doxytag: member="Contact::getCof" ref="d408ca39376bfbf099adc4bf295f6cd5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Contact::getCof           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the coefficient of friction for this contact. 
<p>
Returns the correct coefficient of friction for this contact. If either body is dynamic, and the relative velocity between them is greater than 1.0 mm/sec (should be made a parameter), then it returns the kinetic COF, otherwise it returns the static COF. 
</div>
</div><p>
<a class="anchor" name="126b6d2c37136bd4e28adb70a7a0b481"></a><!-- doxytag: member="Contact::getConstraintError" ref="126b6d2c37136bd4e28adb70a7a0b481" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Contact::getConstraintError           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The error that shows that this contact constraints are violated during dynamic simulation. 
<p>
Each body has a thin layer around it that is <a class="el" href="class_contact.html#a9702d09de3a0153fcd643566fa6ade5" title="Maximum separation distance (in mm) between two bodies that are considered to be...">Contact::THRESHOLD</a> mm thick, and when another body is within that layer, the two bodies are in contact. During dynamic simulation, contacts provide constraints to prevent the two bodies from interpenetrating. However, the constraint is a velocity constraint not a <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> one, so errors in <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> due to numerical issues can occur. If the two bodies get closer than half the contact threshold, we correct this specifying a constraint error in the dynamics, which will serve to move the bodies apart. This routine returns the distance that two bodies have violated that halfway constraint. 
</div>
</div><p>
<a class="anchor" name="2199cd254732a570550ba45cab721ebd"></a><!-- doxytag: member="Contact::getContactDim" ref="2199cd254732a570550ba45cab721ebd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Contact::getContactDim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the contact dimension (number of basis wrenches). 
</div>
</div><p>
<a class="anchor" name="7f872f6ae2ff4e6802359fa8c9a00dc6"></a><!-- doxytag: member="Contact::getContactForcePointers" ref="7f872f6ae2ff4e6802359fa8c9a00dc6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SoSeparator* Contact::getContactForcePointers           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the Inventor root of the pointer geometry for this contact 
</div>
</div><p>
<a class="anchor" name="af757601e743d7fc01027440ed8cfcaa"></a><!-- doxytag: member="Contact::getContactFrame" ref="af757601e743d7fc01027440ed8cfcaa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtransf.html">transf</a> Contact::getContactFrame           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns pose of the contact frame relative to the base frame of body1. 
</div>
</div><p>
<a class="anchor" name="78032db0e33df225ad3d833e474af48a"></a><!-- doxytag: member="Contact::getDynamicContactWrench" ref="78032db0e33df225ad3d833e474af48a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* Contact::getDynamicContactWrench           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current dynamic force acting at this contact. 
</div>
</div><p>
<a class="anchor" name="38d82d8c85add02c9d83afab804df4b3"></a><!-- doxytag: member="Contact::getFrictionType" ref="38d82d8c85add02c9d83afab804df4b3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="contact_8h.html#38dd70084d5973b5981fa757c61e4181">frictionT</a> Contact::getFrictionType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the type of friction modeled at this contact. 
</div>
</div><p>
<a class="anchor" name="e7798c39957d9d342ad2e56107b757ad"></a><!-- doxytag: member="Contact::getLmiDim" ref="e7798c39957d9d342ad2e56107b757ad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Contact::getLmiDim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the dimension of the LMI block for this contact. (used in GFO) 
</div>
</div><p>
<a class="anchor" name="ac5415b56e2843de36a3d96c2eddb50b"></a><!-- doxytag: member="Contact::getMate" ref="ac5415b56e2843de36a3d96c2eddb50b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_contact.html">Contact</a>* Contact::getMate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the other half of this contact pair. 
</div>
</div><p>
<a class="anchor" name="d2e3e9d840a97e44c235259bcbcfc60e"></a><!-- doxytag: member="Contact::getNormal" ref="d2e3e9d840a97e44c235259bcbcfc60e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvec3.html">vec3</a> Contact::getNormal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return contact normal wrt Body1 frame. 
</div>
</div><p>
<a class="anchor" name="ef30f9d47fb3a16e5d75a2782cef8ef0"></a><!-- doxytag: member="Contact::getNormalForceLimit" ref="ef30f9d47fb3a16e5d75a2782cef8ef0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Contact::getNormalForceLimit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the maximum normal force due to torque limits in the hand computed by GFO. 
</div>
</div><p>
<a class="anchor" name="23a161cf61a4c5d92c18451f822bcf7f"></a><!-- doxytag: member="Contact::getPosition" ref="23a161cf61a4c5d92c18451f822bcf7f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classposition.html">position</a> Contact::getPosition           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns contact <a class="el" href="classposition.html" title="A 3-dimensional position and methods to operate on them.">position</a> wrt Body1 frame. 
</div>
</div><p>
<a class="anchor" name="b9d5f0e1c11b51c9894ea3250cf34497"></a><!-- doxytag: member="Contact::inherit" ref="b9d5f0e1c11b51c9894ea3250cf34497" args="(Contact *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contact::inherit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_contact.html">Contact</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This contact inherits some properties from a contact from a previous dynamic time step.<p>
Attempts to save some information from a previously computed dynamics time step. The contact <em>c</em> is from the previous time step, but has been determined to be close enough to this one that it is probably the same contact, having slightly evolved over a time step. 
</div>
</div><p>
<a class="anchor" name="d6dc61692e05b50493dbde17eaacb164"></a><!-- doxytag: member="Contact::localToWorldWrenchBlockMatrix" ref="d6dc61692e05b50493dbde17eaacb164" args="(const std::list&lt; Contact * &gt; &amp;contacts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Contact::localToWorldWrenchBlockMatrix           </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; <a class="el" href="class_contact.html">Contact</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>contacts</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a block matrix made up of individual force to world wrench conversion matrices. 
<p>
Assembles together the localToWorldWrenchMatrix for all the contacts in the list in block diagonal form. 
</div>
</div><p>
<a class="anchor" name="b945418512d75486f769e603a63ba36e"></a><!-- doxytag: member="Contact::localToWorldWrenchMatrix" ref="b945418512d75486f769e603a63ba36e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Contact::localToWorldWrenchMatrix           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the matrix that transforms a force on this contact into a wrench on the other body. 
<p>
The matrix, when multiplied with a wrench applied at this contact will give the resultant wrench applied on the other body in contact (thus computed relative to that object's center of mass), expressed in world <a class="el" href="classcoordinates.html" title="This is the base class for various coordinate representations.">coordinates</a>.<p>
The matrix looks like this: | R 0 | |CR R | Where R is the 3x3 rotation matrix between the coordinate systems and C also contains the cross product matrix that depends on the translation between them. 
</div>
</div><p>
<a class="anchor" name="5bbf145e91ae467b8162b06794c5ebd5"></a><!-- doxytag: member="Contact::normalForceSumMatrix" ref="5bbf145e91ae467b8162b06794c5ebd5" args="(const std::list&lt; Contact * &gt; &amp;contacts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a> Contact::normalForceSumMatrix           </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; <a class="el" href="class_contact.html">Contact</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>contacts</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a matrix that adds just the normal force components of an amplitudes vector. 
<p>
Creates a line vector that, when multiplied by a vector of contact wrench amplitudes returns the sum of the normal components. Therefore, it has 1 in the positions corresponding to normal force amplitudes and 0 in the positions corresponding to friction wrench amplitudes. 
</div>
</div><p>
<a class="anchor" name="75bd54874aef48f9c230fb9d729260f6"></a><!-- doxytag: member="Contact::preventsMotion" ref="75bd54874aef48f9c230fb9d729260f6" args="(const transf &amp;motion) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Contact::preventsMotion           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtransf.html">transf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>motion</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether this contact will prevent motion of body 1 as expressed in local body 1 <a class="el" href="classcoordinates.html" title="This is the base class for various coordinate representations.">coordinates</a><p>
First computes the new location of the contact point using the motion transform (expressed with respect to the body coordinate frame). If the dot product of the contact point motion vector and the contact normal is less than zero, then the contact prevents this motion. 
</div>
</div><p>
<a class="anchor" name="9a488e945014def078175a3b7a2cb850"></a><!-- doxytag: member="Contact::setContactForce" ref="9a488e945014def078175a3b7a2cb850" args="(double *optmx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contact::setContactForce           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>optmx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by GFO routine to set optimal contact force. 
<p>
When the grasp force optimization completes it calls this routine to set this contact's optimal force. This force is a compromise between minimizing internal grasp forces and how close the force is to the boundary of the friction cone, or starting to slip. 
</div>
</div><p>
<a class="anchor" name="7caca6e73c8e8a9b27be7c5de9e34a69"></a><!-- doxytag: member="Contact::setDynamicContactForce" ref="7caca6e73c8e8a9b27be7c5de9e34a69" args="(const vec3 &amp;force)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contact::setDynamicContactForce           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvec3.html">vec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets just the force part of a dynamic wrench using a <a class="el" href="classvec3.html" title="A 3-dimensional double vector and methods to operate on them.">vec3</a> 
</div>
</div><p>
<a class="anchor" name="62ae8ba2aba22af4f61dccad1f67307f"></a><!-- doxytag: member="Contact::setDynamicContactWrench" ref="62ae8ba2aba22af4f61dccad1f67307f" args="(double f[6])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contact::setDynamicContactWrench           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>f</em>[6]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the dynamic force acting at this contact during the current time step. Used when drawing contact forces. 
</div>
</div><p>
<a class="anchor" name="6de167eb9535347be600d2f8d4c75de3"></a><!-- doxytag: member="Contact::setMate" ref="6de167eb9535347be600d2f8d4c75de3" args="(Contact *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contact::setMate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_contact.html">Contact</a> *&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connects the mate contact to this one 
</div>
</div><p>
<a class="anchor" name="c0ba86f43094c7120fda2fd6a4558b21"></a><!-- doxytag: member="Contact::setNormalForceLimit" ref="c0ba86f43094c7120fda2fd6a4558b21" args="(double nfl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contact::setNormalForceLimit           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>nfl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the normal force limit based on hand torque limits as computed during GFO. 
</div>
</div><p>
<a class="anchor" name="4536b5d28a5cb2220bd231c160540e1a"></a><!-- doxytag: member="Contact::setUpFrictionEllipsoid" ref="4536b5d28a5cb2220bd231c160540e1a" args="(int numLatitudes, int numDirs[], double phi[], double eccen[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Contact::setUpFrictionEllipsoid           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numLatitudes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numDirs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>phi</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>eccen</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up frictional forces at this contact using a linearized ellipsoid. 
<p>
Sets up the friction edges of this contact using an ellipsoid approximation. This is convenience function, as friction edges can be set in many ways. However, we currently use PCWF and SFC models which are both cases of linearized ellipsoids, so this function can be used for both.<p>
Consider a 3D friction ellipsoid, where the first two dimensions are tangential frictional force (along X and Y) and the third is frictional torque (along Z). This function samples this ellipsoid at <em>numLatitudes</em> latitudes contained in <em>phi</em>[]; at each latitude l it takes <em>numDirs</em>[l] equally spaced discrete samples. Each of those samples becomes a friction edge, after it is converted to the full 6D space by filling in the other dimensions with zeroes. 
</div>
</div><p>
<a class="anchor" name="cfebdb8da1152081ad31956431131020"></a><!-- doxytag: member="Contact::updateCof" ref="cfebdb8da1152081ad31956431131020" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contact::updateCof           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Updates the coefficient of friction (called when the body materials have changed). 
<p>
Recomputes the COF for this contact. This is called when the material of one of the two bodies is changed. 
</div>
</div><p>
<a class="anchor" name="14886fe15e02a4eb13b2865185c21e9b"></a><!-- doxytag: member="Contact::wrenchFromFrictionEdge" ref="14886fe15e02a4eb13b2865185c21e9b" args="(double *edge, const vec3 &amp;radius, Wrench *wr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Contact::wrenchFromFrictionEdge           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvec3.html">vec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_wrench.html">Wrench</a> *&nbsp;</td>
          <td class="paramname"> <em>wr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
computes a single contact wrench from a friction edge 
<p>
Friction edges contain "normalised" friction information: just the frictional component, and without reference to normal force or coeff of friction (c.o.f.). They only care about the relationship between frictional components.<p>
To get an actual wrench that can be applied at the contact, we must add normal force (normalised here to 1N) and take into account the relationship btw normal force and c.o.f. 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="ce3fec393adedbba95141f81ff4c4ef5"></a><!-- doxytag: member="Contact::frictionEdges" ref="ce3fec393adedbba95141f81ff4c4ef5" args="[6 *MAX_FRICTION_EDGES]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_contact.html#ce3fec393adedbba95141f81ff4c4ef5">Contact::frictionEdges</a>[6 *MAX_FRICTION_EDGES]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
6 x numFrictionEdges matrix of friction cone boundary wrenches used in dynmaics 
<p>
Friction edges contain "normalised" friction information: just the frictional component, and without reference to normal force or coeff of friction (c.o.f.). They only care about the relationship between frictional components. 
</div>
</div><p>
<a class="anchor" name="f65bf1f224046c5ba137f2a4c5f1e138"></a><!-- doxytag: member="Contact::wrench" ref="f65bf1f224046c5ba137f2a4c5f1e138" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_wrench.html">Wrench</a>* <a class="el" href="class_contact.html#f65bf1f224046c5ba137f2a4c5f1e138">Contact::wrench</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of wrenches bounding the <a class="el" href="class_contact.html" title="A contact between 2 bodies.">Contact</a> <a class="el" href="struct_wrench.html" title="A wrench is a 6-vector containing 2 3-vectors for the force and torque components...">Wrench</a> Space (CWS). 
<p>
The CWS is a convex polyhedron that defines the space of wrenches that can be applied at this contact. Also encapsulates normal forces (usually normalised to 1N) and the relationship between normal and frictional components (usually encapsulated in the coefficient of friction). 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/include/<a class="el" href="contact_8h-source.html">contact.h</a><li>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/src/<a class="el" href="contact_8cpp.html">contact.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jul 24 16:39:11 2009 for Graspit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
