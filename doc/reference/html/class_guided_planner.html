<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Graspit: GuidedPlanner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>GuidedPlanner Class Reference</h1><!-- doxytag: class="GuidedPlanner" --><!-- doxytag: inherits="SimAnnPlanner" -->A planner that will fire off child threads to investigate promising states in more detail.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="guided_planner_8h-source.html">guidedPlanner.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for GuidedPlanner:</div>
<div class="dynsection">

<p><center><img src="class_guided_planner.png" usemap="#GuidedPlanner_map" border="0" alt=""></center>
<map name="GuidedPlanner_map">
<area href="class_sim_ann_planner.html" alt="SimAnnPlanner" shape="rect" coords="0,56,99,80">
<area href="class_e_g_planner.html" alt="EGPlanner" shape="rect" coords="0,0,99,24">
</map>
</div>

<p>
<a href="class_guided_planner-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="59f8fa466281bc99834e0530a1b77bac"></a><!-- doxytag: member="GuidedPlanner::GuidedPlanner" ref="59f8fa466281bc99834e0530a1b77bac" args="(Hand *h)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>GuidedPlanner</b> (<a class="el" href="class_hand.html">Hand</a> *h)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aba152cb998c93d9190dcd5afc2e2970"></a><!-- doxytag: member="GuidedPlanner::getType" ref="aba152cb998c93d9190dcd5afc2e2970" args="()" -->
virtual PlannerType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#aba152cb998c93d9190dcd5afc2e2970">getType</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of this planner, for easier run-time check. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#4d202103a4514d39969dc438939546f6">startPlanner</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Also hides the friction cones on the object.  <a href="#4d202103a4514d39969dc438939546f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#09d89d8672d362d0b04bc15ad0d38e99">stopPlanner</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Also stops all children, for good (stops their threads).  <a href="#09d89d8672d362d0b04bc15ad0d38e99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd9a63be5e10417c019038e483c309e4"></a><!-- doxytag: member="GuidedPlanner::pausePlanner" ref="dd9a63be5e10417c019038e483c309e4" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#dd9a63be5e10417c019038e483c309e4">pausePlanner</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not properly implemented yet as this also stops children for good (instead of pausing them). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9460111f2eb81e6e1bb81682c916e810"></a><!-- doxytag: member="GuidedPlanner::resetPlanner" ref="9460111f2eb81e6e1bb81682c916e810" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#9460111f2eb81e6e1bb81682c916e810">resetPlanner</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Also clears the list of states to be avoided. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="55ab4468ab4353ca95575a283ef694de"></a><!-- doxytag: member="GuidedPlanner::setMaxChildren" ref="55ab4468ab4353ca95575a283ef694de" args="(int c)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setMaxChildren</b> (int c)</td></tr>

<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="35d2e3833e51880ee7f00c9e7472d43b"></a><!-- doxytag: member="GuidedPlanner::mBestListSize" ref="35d2e3833e51880ee7f00c9e7472d43b" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#35d2e3833e51880ee7f00c9e7472d43b">mBestListSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of child results that are saved. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21a58fb93d61c123499fd6e2f7dfd0c3"></a><!-- doxytag: member="GuidedPlanner::mChildSeedSize" ref="21a58fb93d61c123499fd6e2f7dfd0c3" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#21a58fb93d61c123499fd6e2f7dfd0c3">mChildSeedSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Max size of child seeds list. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ebfca0f7e0d6189b8075a76fe08bf278"></a><!-- doxytag: member="GuidedPlanner::mDistanceThreshold" ref="ebfca0f7e0d6189b8075a76fe08bf278" args="" -->
float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#ebfca0f7e0d6189b8075a76fe08bf278">mDistanceThreshold</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Min distance separating child seeds. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4688bad04144a090757050f0ccedbb87"></a><!-- doxytag: member="GuidedPlanner::mMinChildEnergy" ref="4688bad04144a090757050f0ccedbb87" args="" -->
float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#4688bad04144a090757050f0ccedbb87">mMinChildEnergy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Min energy for a state to be deemed good enough to be used to seed a child. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2bee0b37715797e09b0a4e47faa7b9c"></a><!-- doxytag: member="GuidedPlanner::mChildEnergyType" ref="a2bee0b37715797e09b0a4e47faa7b9c" args="" -->
SearchEnergyType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#a2bee0b37715797e09b0a4e47faa7b9c">mChildEnergyType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Energy computation type used by children. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0376eba718ae1cb0bb95515844aa355a"></a><!-- doxytag: member="GuidedPlanner::mMaxChildSteps" ref="0376eba718ae1cb0bb95515844aa355a" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#0376eba718ae1cb0bb95515844aa355a">mMaxChildSteps</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Max iterations done by a child. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#e2685366f5a1c8787f4671c3909a7fc5">startChild</a> (const <a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fires of a child planner that will be seeded with the given state.  <a href="#e2685366f5a1c8787f4671c3909a7fc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#778fd00a1d1ca879ab0dd23083dba127">stopChild</a> (<a class="el" href="class_sim_ann_planner.html">SimAnnPlanner</a> *pl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops a child planner, gets its solutions and stops its thread.  <a href="#778fd00a1d1ca879ab0dd23083dba127"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#06e00b268d293d77be19da581d6b5115">checkChildren</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if any of the currently active children have finished their execution.  <a href="#06e00b268d293d77be19da581d6b5115"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#ce851c215446dc073e454c4b57e9a329">mainLoop</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores states to be used as "seeds" for children, and fires new children when appropriate.  <a href="#ce851c215446dc073e454c4b57e9a329"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="847c725e2a8726b14df2578c6c633c64"></a><!-- doxytag: member="GuidedPlanner::mMaxChildren" ref="847c725e2a8726b14df2578c6c633c64" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#847c725e2a8726b14df2578c6c633c64">mMaxChildren</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The max number of children that canbe used. Usually correlated with the number of cores available. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="666cdb60c02bdb26d4aa201b18a93818"></a><!-- doxytag: member="GuidedPlanner::mChildPlanners" ref="666cdb60c02bdb26d4aa201b18a93818" args="" -->
std::vector&lt; <a class="el" href="class_sim_ann_planner.html">SimAnnPlanner</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#666cdb60c02bdb26d4aa201b18a93818">mChildPlanners</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The list of currently active child planners. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f7905c98b9b3d493e396fb2339c069ca"></a><!-- doxytag: member="GuidedPlanner::mChildSeeds" ref="f7905c98b9b3d493e396fb2339c069ca" args="" -->
std::list&lt; <a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#f7905c98b9b3d493e396fb2339c069ca">mChildSeeds</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of seeds that haven't been used yet. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::list&lt; <a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#8d9121993cdab12267e5429418b73c2f">mAvoidList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of states that should be avoided by the search.  <a href="#8d9121993cdab12267e5429418b73c2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#dda0dfe870e2b83dec165412b333785c">mChildClones</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the children use clones of the current hand.  <a href="#dda0dfe870e2b83dec165412b333785c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_guided_planner.html#55949e31c18bc70b4d67e0c2e02150cd">mChildThreads</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the children run in their own threads.  <a href="#55949e31c18bc70b4d67e0c2e02150cd"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A planner that will fire off child threads to investigate promising states in more detail. 
<p>
The <a class="el" href="class_guided_planner.html" title="A planner that will fire off child threads to investigate promising states in more...">GuidedPlanner</a> is a more complicated version of the <a class="el" href="class_sim_ann.html">SimAnn</a> planner. It will run just like the <a class="el" href="class_sim_ann.html">SimAnn</a> planner, but whenever it finds "good" states it will fire of children that run in separate threads to investigate the "good" states in more detail. The children will use a different type of EnergyCalculator which actually closes the hand and computes exact grasp quality for each state. If the time of planning is not an issue (2 mins or more) this is the best planner to guarantee finding exact force-closure grasps. Might be unstable due to multi-threaded operation.<p>
States that have been sent to a child planner are remembered and avoided - no point in exploring them anymore since a child planner is exploring each of them in great detail.<p>
Whenever a child thread finishes, the main planner will take its best solution and store it in its own solution list. Therefore, the list of solutions of the main planner (mBestList) is actually a list on solutions, one from each child that has finished.<p>
In general, planners operating in eigengrasp space will always find "pre-grasps" that must usually be transformed into actual grasps by closing the fingers, or doing some slightly modified version of autoGrasp. The exact transformation from pre-grasp to final grasp is simple, but usually hidden inside the <a class="el" href="class_search_energy.html" title="Computes the &quot;quality&quot; of a HandObjectState, which encapsulates the state...">SearchEnergy</a> class which analyzes pre-grasps. That class is kind of hard to understand, as it is old code in bad need of a shake-up.<p>
Starting in version 2.1.0, the main <a class="el" href="class_guided_planner.html" title="A planner that will fire off child threads to investigate promising states in more...">GuidedPlanner</a> also stores the final grasp for any of its solutions. Therefore, for each solution, the best list of this planner will contain the pre-grasp followed by the final grasp. This wsa done in an attempt to make this planner usable "off the shelf" without having to worry about recomputing exact final grasps after its done. See the stopChild(...) function for details about how the solutions recovered from children threads are saved. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="06e00b268d293d77be19da581d6b5115"></a><!-- doxytag: member="GuidedPlanner::checkChildren" ref="06e00b268d293d77be19da581d6b5115" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GuidedPlanner::checkChildren           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if any of the currently active children have finished their execution. 
<p>
Deletes any children that are done. If there are seeds available and emtpty children slots it also fires of new children. If a new child is fired and the main planner is still in the area, the main planner is also reset so it goes plan somewhere else. 
</div>
</div><p>
<a class="anchor" name="ce851c215446dc073e454c4b57e9a329"></a><!-- doxytag: member="GuidedPlanner::mainLoop" ref="ce851c215446dc073e454c4b57e9a329" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GuidedPlanner::mainLoop           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stores states to be used as "seeds" for children, and fires new children when appropriate. 
<p>
Does the usual main loop of a <a class="el" href="class_sim_ann.html">SimAnn</a> planner, but checks if the current state is good enough to be placed in the list of seeds to be used for children. The list of seeds is also pruned to remove similar state, and only keep a list of "unique" seeds. 
<p>Reimplemented from <a class="el" href="class_sim_ann_planner.html#0c55e5be635754fdc3dd35af10dd6bf7">SimAnnPlanner</a>.</p>

</div>
</div><p>
<a class="anchor" name="e2685366f5a1c8787f4671c3909a7fc5"></a><!-- doxytag: member="GuidedPlanner::startChild" ref="e2685366f5a1c8787f4671c3909a7fc5" args="(const GraspPlanningState *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GuidedPlanner::startChild           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> *&nbsp;</td>
          <td class="paramname"> <em>seed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fires of a child planner that will be seeded with the given state. 
<p>
Starts a child and gives it as an "input" state the <em>seed</em>. The child will then be biased to spend more time in the vicinity of this state. The exact confidence levels in the seed state are hard-coded in.<p>
Also hard-coded are the annealing parameters that the child uses (ANNEALING_STRICT) and other parameters for the child. The seed state is also marked visually to give some visual feedback, since the child planners typically use cloned hands which are hidden. 
</div>
</div><p>
<a class="anchor" name="4d202103a4514d39969dc438939546f6"></a><!-- doxytag: member="GuidedPlanner::startPlanner" ref="4d202103a4514d39969dc438939546f6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GuidedPlanner::startPlanner           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Also hides the friction cones on the object. 
<p>
Since child planner will actually compute actual contacts with the object, we disable rendering of friction cones, as rendering requests from different threads can cause problems. 
<p>Reimplemented from <a class="el" href="class_e_g_planner.html#d129bfd959b538336874e7349050b92a">EGPlanner</a>.</p>

</div>
</div><p>
<a class="anchor" name="778fd00a1d1ca879ab0dd23083dba127"></a><!-- doxytag: member="GuidedPlanner::stopChild" ref="778fd00a1d1ca879ab0dd23083dba127" args="(SimAnnPlanner *pl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GuidedPlanner::stopChild           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sim_ann_planner.html">SimAnnPlanner</a> *&nbsp;</td>
          <td class="paramname"> <em>pl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stops a child planner, gets its solutions and stops its thread. 
<p>
Stops a child, and waits for the child thread to finish. After that, it retrieves the solutions found by the child, and places them in the list of solutions and also in the list of states to be avoided in the future. Solutions are also marked visually.<p>
Note that, for each solution recovered from a child, this function also reconstructs the final grasp (remember that solutions are usually pre-grasps) and saves BOTH in the list of solutions. 
</div>
</div><p>
<a class="anchor" name="09d89d8672d362d0b04bc15ad0d38e99"></a><!-- doxytag: member="GuidedPlanner::stopPlanner" ref="09d89d8672d362d0b04bc15ad0d38e99" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GuidedPlanner::stopPlanner           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Also stops all children, for good (stops their threads). 
<p>
After the children have been stopped, it also deletes them. Any current solutions of the children are lost. 
<p>Reimplemented from <a class="el" href="class_e_g_planner.html#f0ebf2c8bb0bc108bd7666a227c6945a">EGPlanner</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="8d9121993cdab12267e5429418b73c2f"></a><!-- doxytag: member="GuidedPlanner::mAvoidList" ref="8d9121993cdab12267e5429418b73c2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a>*&gt; <a class="el" href="class_guided_planner.html#8d9121993cdab12267e5429418b73c2f">GuidedPlanner::mAvoidList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A list of states that should be avoided by the search. 
<p>
They are avoded because they have either been used by a child or are scheduled to be used by one. Essentially, it is the union of mChildSeeds and mBestList. 
</div>
</div><p>
<a class="anchor" name="dda0dfe870e2b83dec165412b333785c"></a><!-- doxytag: member="GuidedPlanner::mChildClones" ref="dda0dfe870e2b83dec165412b333785c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_guided_planner.html#dda0dfe870e2b83dec165412b333785c">GuidedPlanner::mChildClones</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether the children use clones of the current hand. 
<p>
True by default, should be set to false only for debugging purposes. 
</div>
</div><p>
<a class="anchor" name="55949e31c18bc70b4d67e0c2e02150cd"></a><!-- doxytag: member="GuidedPlanner::mChildThreads" ref="55949e31c18bc70b4d67e0c2e02150cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_guided_planner.html#55949e31c18bc70b4d67e0c2e02150cd">GuidedPlanner::mChildThreads</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether the children run in their own threads. 
<p>
True by default, should be set to false only for debugging purposes. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/include/EGPlanner/<a class="el" href="guided_planner_8h-source.html">guidedPlanner.h</a><li>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/src/EGPlanner/guidedPlanner.cpp</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jul 24 16:39:12 2009 for Graspit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
