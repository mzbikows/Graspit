<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Graspit: EGPlanner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>EGPlanner Class Reference</h1><!-- doxytag: class="EGPlanner" --><code>#include &lt;<a class="el" href="eg_planner_8h-source.html">egPlanner.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for EGPlanner:</div>
<div class="dynsection">

<p><center><img src="class_e_g_planner.png" usemap="#EGPlanner_map" border="0" alt=""></center>
<map name="EGPlanner_map">
<area href="class_grasp_tester.html" alt="GraspTester" shape="rect" coords="0,56,99,80">
<area href="class_list_planner.html" alt="ListPlanner" shape="rect" coords="109,56,208,80">
<area href="class_sim_ann_planner.html" alt="SimAnnPlanner" shape="rect" coords="218,56,317,80">
<area href="class_guided_planner.html" alt="GuidedPlanner" shape="rect" coords="109,112,208,136">
<area href="class_loop_planner.html" alt="LoopPlanner" shape="rect" coords="218,112,317,136">
<area href="class_time_tester.html" alt="TimeTester" shape="rect" coords="327,112,426,136">
<area href="class_m_t_tester.html" alt="MTTester" shape="rect" coords="327,168,426,192">
</map>
</div>

<p>
<a href="class_e_g_planner-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Signals</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7f3fccc9ce296d03c276fa494b1bc325"></a><!-- doxytag: member="EGPlanner::update" ref="7f3fccc9ce296d03c276fa494b1bc325" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#7f3fccc9ce296d03c276fa494b1bc325">update</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To be emitted during the searh as a measure of progress. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#4678fa5f872782f1c6f2523697459e62">complete</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To be emitted when planner stops.  <a href="#4678fa5f872782f1c6f2523697459e62"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b8806fea549523418ed94750de856b9d"></a><!-- doxytag: member="EGPlanner::EGPlanner" ref="b8806fea549523418ed94750de856b9d" args="(Hand *h)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#b8806fea549523418ed94750de856b9d">EGPlanner</a> (<a class="el" href="class_hand.html">Hand</a> *h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The constructor is desigend NOT to be called by sub-classes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3255e056eec34f89a956f62eeb627df"></a><!-- doxytag: member="EGPlanner::getType" ref="a3255e056eec34f89a956f62eeb627df" args="()=0" -->
virtual PlannerType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#a3255e056eec34f89a956f62eeb627df">getType</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of this planner, for easier run-time check. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a329b1b9287344d2fa3281efb3190845"></a><!-- doxytag: member="EGPlanner::initialized" ref="a329b1b9287344d2fa3281efb3190845" args="()" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#a329b1b9287344d2fa3281efb3190845">initialized</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the planner if it has all the information needed to start planning. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#21dcde4ecb622ce4f21f16716891fb32">resetPlanner</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to restart the search from the beginning.  <a href="#21dcde4ecb622ce4f21f16716891fb32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d129bfd959b538336874e7349050b92a"></a><!-- doxytag: member="EGPlanner::startPlanner" ref="d129bfd959b538336874e7349050b92a" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#d129bfd959b538336874e7349050b92a">startPlanner</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the loops. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b2a2bcae7f1ec184e128a589f4e91ffa"></a><!-- doxytag: member="EGPlanner::pausePlanner" ref="b2a2bcae7f1ec184e128a589f4e91ffa" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#b2a2bcae7f1ec184e128a589f4e91ffa">pausePlanner</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pause the loops; planner can be re-started. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#f0ebf2c8bb0bc108bd7666a227c6945a">stopPlanner</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops the planner FOR GOOD.  <a href="#f0ebf2c8bb0bc108bd7666a227c6945a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4b53f60ac4b7bb6d3112136545bcb1d0"></a><!-- doxytag: member="EGPlanner::createAndUseClone" ref="4b53f60ac4b7bb6d3112136545bcb1d0" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#4b53f60ac4b7bb6d3112136545bcb1d0">createAndUseClone</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the planner to create and use a clone of the hand passed to the constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#d74401766f6860298ec8c4a0146a94bf">showClone</a> (bool s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add (and thus render) or remove (and thus hide) the clone from the world scene graph.  <a href="#d74401766f6860298ec8c4a0146a94bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#a3cf97e30a8d892978c00d2a20761927">startThread</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the planner to start and run in its own thread.  <a href="#a3cf97e30a8d892978c00d2a20761927"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9802a361b820bafeaf3a6e0d4b07c37f"></a><!-- doxytag: member="EGPlanner::getState" ref="9802a361b820bafeaf3a6e0d4b07c37f" args="()" -->
PlannerState&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#9802a361b820bafeaf3a6e0d4b07c37f">getState</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current state of the planner (ready, running, etc.). Thread-safe. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="97b93e67a28092f53462bae9e91b6c0e"></a><!-- doxytag: member="EGPlanner::isActive" ref="97b93e67a28092f53462bae9e91b6c0e" args="()" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#97b93e67a28092f53462bae9e91b6c0e">isActive</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function; return whether current state is RUNNING or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="265b2ede1d0eb16dd198572ee314717c"></a><!-- doxytag: member="EGPlanner::isReady" ref="265b2ede1d0eb16dd198572ee314717c" args="()" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#265b2ede1d0eb16dd198572ee314717c">isReady</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience function; return whether current state is READY or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="161a5807345e9b6ee7ec418bae814b39"></a><!-- doxytag: member="EGPlanner::invalidateReset" ref="161a5807345e9b6ee7ec418bae814b39" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#161a5807345e9b6ee7ec418bae814b39">invalidateReset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the planner that its initialization is no longer valid and new input must be provided. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b44beee4f22cab75fa233138fda3321e"></a><!-- doxytag: member="EGPlanner::setEnergyType" ref="b44beee4f22cab75fa233138fda3321e" args="(SearchEnergyType s)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#b44beee4f22cab75fa233138fda3321e">setEnergyType</a> (SearchEnergyType s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the planner what kind of energy calculator to use. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fa0342e22d1fd669caad2a20a01a823f"></a><!-- doxytag: member="EGPlanner::setContactType" ref="fa0342e22d1fd669caad2a20a01a823f" args="(SearchContactType c)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#fa0342e22d1fd669caad2a20a01a823f">setContactType</a> (SearchContactType c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the planner what kind of virtual contact computation to use. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="84bed0825aad3e9866d6d37c99f81a6b"></a><!-- doxytag: member="EGPlanner::setRenderType" ref="84bed0825aad3e9866d6d37c99f81a6b" args="(RenderType r)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setRenderType</b> (RenderType r)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e908b23c3ec3ac7091d79048b8a0d709"></a><!-- doxytag: member="EGPlanner::setMaxSteps" ref="e908b23c3ec3ac7091d79048b8a0d709" args="(int s)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setMaxSteps</b> (int s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6e5c5ebe88bf8f87461d34cd6ba7364c"></a><!-- doxytag: member="EGPlanner::setRepeat" ref="6e5c5ebe88bf8f87461d34cd6ba7364c" args="(bool r)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setRepeat</b> (bool r)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4ac1dd35e005a26d87e1e474ff12247a"></a><!-- doxytag: member="EGPlanner::setMaxTime" ref="4ac1dd35e005a26d87e1e474ff12247a" args="(int t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setMaxTime</b> (int t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bf8d9e83fd044bbc7bcb69d983bb60c6"></a><!-- doxytag: member="EGPlanner::getGrasp" ref="bf8d9e83fd044bbc7bcb69d983bb60c6" args="(int i)" -->
virtual const <a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#bf8d9e83fd044bbc7bcb69d983bb60c6">getGrasp</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the i-th state from the list of solutions mBestList. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d87b4fc81c266c6a6d10d2879476084"></a><!-- doxytag: member="EGPlanner::showGrasp" ref="3d87b4fc81c266c6a6d10d2879476084" args="(int i)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#3d87b4fc81c266c6a6d10d2879476084">showGrasp</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renders the i-th state from the list of solutions mBestList. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a369dde104ea418f326612c4a6a5cd38"></a><!-- doxytag: member="EGPlanner::getListSize" ref="a369dde104ea418f326612c4a6a5cd38" args="()" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#a369dde104ea418f326612c4a6a5cd38">getListSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the mBestList list of solutions. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="adc7e8c04adf29583f92d42ebfb4c3dd"></a><!-- doxytag: member="EGPlanner::clearSolutions" ref="adc7e8c04adf29583f92d42ebfb4c3dd" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#adc7e8c04adf29583f92d42ebfb4c3dd">clearSolutions</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the list of solutions mBestList. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fcac4ae50a826e8ab5a85b71f16621b6"></a><!-- doxytag: member="EGPlanner::getCurrentStep" ref="fcac4ae50a826e8ab5a85b71f16621b6" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>getCurrentStep</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c371012efc231b9bd40cabcd02200310"></a><!-- doxytag: member="EGPlanner::getHand" ref="c371012efc231b9bd40cabcd02200310" args="()" -->
<a class="el" href="class_hand.html">Hand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>getHand</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0bf13af0ce17015de9446acb2eb281f"></a><!-- doxytag: member="EGPlanner::getRunningTime" ref="a0bf13af0ce17015de9446acb2eb281f" args="()" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#a0bf13af0ce17015de9446acb2eb281f">getRunningTime</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The time elapsed since the last reset. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bbfad4af62349a623bee031e0a4d22b2"></a><!-- doxytag: member="EGPlanner::setInput" ref="bbfad4af62349a623bee031e0a4d22b2" args="(unsigned char input, bool on=true)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#bbfad4af62349a623bee031e0a4d22b2">setInput</a> (unsigned char input, bool on=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Can be used to set what kind of information is used from the "target state". <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="63223471ab3727414144d2746f524389"></a><!-- doxytag: member="EGPlanner::getTargetState" ref="63223471ab3727414144d2746f524389" args="()" -->
<a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#63223471ab3727414144d2746f524389">getTargetState</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the "target state" that is used as a model during the search. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="68042419db31aff46b22c062c74f3081"></a><!-- doxytag: member="EGPlanner::getInputType" ref="68042419db31aff46b22c062c74f3081" args="()" -->
unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>getInputType</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d74614117957da7aea9cb876e252310"></a><!-- doxytag: member="EGPlanner::setStatStream" ref="6d74614117957da7aea9cb876e252310" args="(std::ostream *out) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#6d74614117957da7aea9cb876e252310">setStatStream</a> (std::ostream *out) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the stream for outputting stats and info. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#88ae0f054367641a48a55e88b387acf0">init</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains initialization that is COMMON between this and all subclasses.  <a href="#88ae0f054367641a48a55e88b387acf0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#01c019b885c76e1834b338906f93d510">render</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A decision is made whether to put in a redraw request to the scene graph.  <a href="#01c019b885c76e1834b338906f93d510"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ae3f72545241eef439a92a3be5fcc01"></a><!-- doxytag: member="EGPlanner::processInput" ref="6ae3f72545241eef439a92a3be5fcc01" args="()" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#6ae3f72545241eef439a92a3be5fcc01">processInput</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the values in the mTargetState based in the mInputType flag. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#c6d20672f9206b1f4f12700fac988ded">resetParameters</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets all the inner parameters. Can be called while planner is running as well.  <a href="#c6d20672f9206b1f4f12700fac988ded"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f855baed391ac5ebf16093987661dc97"></a><!-- doxytag: member="EGPlanner::checkTerminationConditions" ref="f855baed391ac5ebf16093987661dc97" args="()" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#f855baed391ac5ebf16093987661dc97">checkTerminationConditions</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether we should terminate the planner, either because maxSteps or maxTime have been exceeded. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="46bab26c274bb919f1c6d5507b8363cb"></a><!-- doxytag: member="EGPlanner::run" ref="46bab26c274bb919f1c6d5507b8363cb" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#46bab26c274bb919f1c6d5507b8363cb">run</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The entry point of child threads. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4a89f42033dee5a21d6aad0f07b0b57"></a><!-- doxytag: member="EGPlanner::threadLoop" ref="a4a89f42033dee5a21d6aad0f07b0b57" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#a4a89f42033dee5a21d6aad0f07b0b57">threadLoop</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main loop that child threads run in. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#dcb78e4d0b233ce826c5d7a532b9d636">setState</a> (PlannerState s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current state of the planner.  <a href="#dcb78e4d0b233ce826c5d7a532b9d636"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#c403f74f10f0c779622cc39b21fa1336">addToListOfUniqueSolutions</a> (<a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> *s, std::list&lt; <a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> * &gt; *list, double distance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function that helps maintain a list of UNIQUE solutions.  <a href="#c403f74f10f0c779622cc39b21fa1336"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ac8000b8f3f5a847502d67ae8f516f36"></a><!-- doxytag: member="EGPlanner::stateDistance" ref="ac8000b8f3f5a847502d67ae8f516f36" args="(const GraspPlanningState *s1, const GraspPlanningState *s2)" -->
virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#ac8000b8f3f5a847502d67ae8f516f36">stateDistance</a> (const <a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> *s1, const <a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> *s2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function that returns a measure of how similar two states are. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10cb157bc147c983eee69b2c93ad579e"></a><!-- doxytag: member="EGPlanner::mainLoop" ref="10cb157bc147c983eee69b2c93ad579e" args="()=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#10cb157bc147c983eee69b2c93ad579e">mainLoop</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pure abstract function to be written in all subclasses. This is where most of the real planning is done. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c17585c3627c9287bb37950640b3f993"></a><!-- doxytag: member="EGPlanner::sensorCB" ref="c17585c3627c9287bb37950640b3f993" args="(void *data, SoSensor *)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#c17585c3627c9287bb37950640b3f993">sensorCB</a> (void *data, SoSensor *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The idle sensor callback, which calls <a class="el" href="class_e_g_planner.html#10cb157bc147c983eee69b2c93ad579e" title="Pure abstract function to be written in all subclasses. This is where most of the...">mainLoop()</a> during single-threaded operation. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d54773ed1394bad5e1259b7dcb140b5"></a><!-- doxytag: member="EGPlanner::mHand" ref="3d54773ed1394bad5e1259b7dcb140b5" args="" -->
<a class="el" href="class_hand.html">Hand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#3d54773ed1394bad5e1259b7dcb140b5">mHand</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the hand that the planner is using. Might be a real hand from the GraspIt world or a clone of one. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="af2159ef88bcca44c65debf05772abf4"></a><!-- doxytag: member="EGPlanner::mUsesClone" ref="af2159ef88bcca44c65debf05772abf4" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>mUsesClone</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8e99e08cdc68f3ffee58194389ca6360"></a><!-- doxytag: member="EGPlanner::mOut" ref="8e99e08cdc68f3ffee58194389ca6360" args="" -->
std::ostream *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#8e99e08cdc68f3ffee58194389ca6360">mOut</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is where the planner (and its <a class="el" href="class_search_energy.html" title="Computes the &quot;quality&quot; of a HandObjectState, which encapsulates the state...">SearchEnergy</a>) will spit their output. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d66abe881d0f9fd7131d2f0483948eca"></a><!-- doxytag: member="EGPlanner::mCurrentState" ref="d66abe881d0f9fd7131d2f0483948eca" args="" -->
<a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#d66abe881d0f9fd7131d2f0483948eca">mCurrentState</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current state of the planner (see the <a class="el" href="class_hand_object_state.html">HandObjectState</a> class for details). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5542c31821ada2fff152888f7125b6d9"></a><!-- doxytag: member="EGPlanner::mEnergyCalculator" ref="5542c31821ada2fff152888f7125b6d9" args="" -->
<a class="el" href="class_search_energy.html">SearchEnergy</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#5542c31821ada2fff152888f7125b6d9">mEnergyCalculator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The instance of the <a class="el" href="class_search_energy.html" title="Computes the &quot;quality&quot; of a HandObjectState, which encapsulates the state...">SearchEnergy</a> class that this planner can use to compute the "quality" of a state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="981fe0612598a7fa0f926e83e26ec666"></a><!-- doxytag: member="EGPlanner::mCurrentStep" ref="981fe0612598a7fa0f926e83e26ec666" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#981fe0612598a7fa0f926e83e26ec666">mCurrentStep</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">How many iterations this planner has done since the last reset. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f42d39b195c80382b94194bad5631ace"></a><!-- doxytag: member="EGPlanner::mMaxSteps" ref="f42d39b195c80382b94194bad5631ace" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#f42d39b195c80382b94194bad5631ace">mMaxSteps</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of iterations allowed. mMaxSteps = -1 means run forever. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7f6c612dfe270a65e37d2562aa9f3c9e"></a><!-- doxytag: member="EGPlanner::mRepeat" ref="7f6c612dfe270a65e37d2562aa9f3c9e" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#7f6c612dfe270a65e37d2562aa9f3c9e">mRepeat</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells us what happens when mMaxSteps have been exceeded: the planner will either stop or restart. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c3acde87b6eb742a12311a897e94f304"></a><!-- doxytag: member="EGPlanner::mRenderType" ref="c3acde87b6eb742a12311a897e94f304" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#c3acde87b6eb742a12311a897e94f304">mRenderType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These options decide when and what the planner should render. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d598ca57449a244501df25d6581ec9f"></a><!-- doxytag: member="EGPlanner::mRenderCount" ref="5d598ca57449a244501df25d6581ec9f" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>mRenderCount</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9bfc13f859f80a419a80c6816090b6a"></a><!-- doxytag: member="EGPlanner::mLastRenderState" ref="a9bfc13f859f80a419a80c6816090b6a" args="" -->
const <a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#a9bfc13f859f80a419a80c6816090b6a">mLastRenderState</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The last rendered state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="343cfef8bdfd21d6e1ac8e01ab678b01"></a><!-- doxytag: member="EGPlanner::mRunningTime" ref="343cfef8bdfd21d6e1ac8e01ab678b01" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#343cfef8bdfd21d6e1ac8e01ab678b01">mRunningTime</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time elapsed since last reset, in seconds. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="41ad78758df3c30439ed2b3a9768c1f2"></a><!-- doxytag: member="EGPlanner::mMaxTime" ref="41ad78758df3c30439ed2b3a9768c1f2" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#41ad78758df3c30439ed2b3a9768c1f2">mMaxTime</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum time allowed. mMaxTime = -1 means no time limit. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7f055ca21c46d6d1b16caaa27aedd2ce"></a><!-- doxytag: member="EGPlanner::mStartTime" ref="7f055ca21c46d6d1b16caaa27aedd2ce" args="" -->
clock_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#7f055ca21c46d6d1b16caaa27aedd2ce">mStartTime</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The time at which the planner was started. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9e5f8601c16b6289c104044bc4d39686"></a><!-- doxytag: member="EGPlanner::mTargetState" ref="9e5f8601c16b6289c104044bc4d39686" args="" -->
<a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#9e5f8601c16b6289c104044bc4d39686">mTargetState</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If used, this is a target state, or an "input" state provided by the user as a guideline. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98712b41e97a2cc3b638c9ffcc92967b"></a><!-- doxytag: member="EGPlanner::mInputType" ref="98712b41e97a2cc3b638c9ffcc92967b" args="" -->
unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#98712b41e97a2cc3b638c9ffcc92967b">mInputType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the planner if it should process its own input state, based on Cyberglove, Flock of Birds etc. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d55b6ac40b748d9da7c4720d994f913f"></a><!-- doxytag: member="EGPlanner::mIdleSensor" ref="d55b6ac40b748d9da7c4720d994f913f" args="" -->
SoSensor *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#d55b6ac40b748d9da7c4720d994f913f">mIdleSensor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For single-threaded operation, using an idle sensor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1ef613d6197dfd5afe76d5beedb89fe5"></a><!-- doxytag: member="EGPlanner::mMultiThread" ref="1ef613d6197dfd5afe76d5beedb89fe5" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#1ef613d6197dfd5afe76d5beedb89fe5">mMultiThread</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag that indicates single- or multi-threaded operation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fa27a863a36eb7da959fd578d9a3409e"></a><!-- doxytag: member="EGPlanner::mControlMutex" ref="fa27a863a36eb7da959fd578d9a3409e" args="" -->
QMutex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#fa27a863a36eb7da959fd578d9a3409e">mControlMutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex for synchronizing threads. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c00b3e801fcf34912c8ea8d2ab407ad"></a><!-- doxytag: member="EGPlanner::mState" ref="0c00b3e801fcf34912c8ea8d2ab407ad" args="" -->
PlannerState&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#0c00b3e801fcf34912c8ea8d2ab407ad">mState</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current state of the planner (ready, running, paused, etc.). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="74f408db0d80f265cc8e937b8d464876"></a><!-- doxytag: member="EGPlanner::mBestList" ref="74f408db0d80f265cc8e937b8d464876" args="" -->
std::list&lt; <a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_g_planner.html#74f408db0d80f265cc8e937b8d464876">mBestList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list that is normally used to keep track of solutions found so far. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="class_e_g_planner.html">EGPlanner</a> is one of the main classes that are available in GraspIt! for doing grasp planning. Unlike the name suggests, it is not necessarily restricted to running in <a class="el" href="class_eigen_grasp.html" title="A single eigengrasp direction.">EigenGrasp</a> space. It is designed to take care of loops, lists of solutions, etc. and allow sub-classes to just focus on the planning itself. When subclassing from this class, you just have to define the <a class="el" href="class_e_g_planner.html#10cb157bc147c983eee69b2c93ad579e" title="Pure abstract function to be written in all subclasses. This is where most of the...">mainLoop()</a> function which here is pure abstract.<p>
It can operate either in a single-thread fashion, where the looping functionality is provided using a Coin IdleSensor, or it can start it's own thread which spins forever and calls the <a class="el" href="class_e_g_planner.html#10cb157bc147c983eee69b2c93ad579e" title="Pure abstract function to be written in all subclasses. This is where most of the...">mainLoop()</a>.<p>
It can either operate on the GraspIt hand that is passed as an argument, or it can create its own "clone" of the hand to do the planning on. If multi-threaded, the planner will ALWAYS run on a clone. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c403f74f10f0c779622cc39b21fa1336"></a><!-- doxytag: member="EGPlanner::addToListOfUniqueSolutions" ref="c403f74f10f0c779622cc39b21fa1336" args="(GraspPlanningState *s, std::list&lt; GraspPlanningState * &gt; *list, double distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EGPlanner::addToListOfUniqueSolutions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; <a class="el" href="class_grasp_planning_state.html">GraspPlanningState</a> * &gt; *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>distance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper function that helps maintain a list of UNIQUE solutions. 
<p>
Attempts to maintain a list of unique solutions. Therefore, whenever a new state is added to the list, we check if any of the states that are already in the list are within a given distance of the new state. If so, the best one is kept and the other one is thrown away. This method does not gurantee unique states, but it comes close and runs in linear time for each addition, rather than square time for maintenance. 
</div>
</div><p>
<a class="anchor" name="4678fa5f872782f1c6f2523697459e62"></a><!-- doxytag: member="EGPlanner::complete" ref="4678fa5f872782f1c6f2523697459e62" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EGPlanner::complete           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To be emitted when planner stops. 
<p>
To be emitted when planner stops, either through an explicit termination user command or by exceeding mMaxSteps or mMaxTime. 
</div>
</div><p>
<a class="anchor" name="88ae0f054367641a48a55e88b387acf0"></a><!-- doxytag: member="EGPlanner::init" ref="88ae0f054367641a48a55e88b387acf0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EGPlanner::init           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains initialization that is COMMON between this and all subclasses. 
<p>
Class-specific initialization will go in the constructor.<p>
Also sets the state of the planner to INIT, which is default initialization. 
</div>
</div><p>
<a class="anchor" name="01c019b885c76e1834b338906f93d510"></a><!-- doxytag: member="EGPlanner::render" ref="01c019b885c76e1834b338906f93d510" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EGPlanner::render           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A decision is made whether to put in a redraw request to the scene graph. 
<p>
WARNING: when multi-threaded, it is best to avoid ALL rendering requests issued from inside the planner. 
</div>
</div><p>
<a class="anchor" name="c6d20672f9206b1f4f12700fac988ded"></a><!-- doxytag: member="EGPlanner::resetParameters" ref="c6d20672f9206b1f4f12700fac988ded" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EGPlanner::resetParameters           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets all the inner parameters. Can be called while planner is running as well. 
<p>
This is the part of <a class="el" href="class_e_g_planner.html#21dcde4ecb622ce4f21f16716891fb32" title="Used to restart the search from the beginning.">resetPlanner()</a> that can also be called while the planner is running to cause it to start from the beginning, without affecting the currently computed solutions. 
<p>Reimplemented in <a class="el" href="class_list_planner.html#f2348e9bdd548fefd5fc9be2e8e22c36">ListPlanner</a>, <a class="el" href="class_loop_planner.html#8b1aa30c9f89506361d4895eea8a6efb">LoopPlanner</a>, and <a class="el" href="class_sim_ann_planner.html#7041dd183c7915646202d240014a108e">SimAnnPlanner</a>.</p>

</div>
</div><p>
<a class="anchor" name="21dcde4ecb622ce4f21f16716891fb32"></a><!-- doxytag: member="EGPlanner::resetPlanner" ref="21dcde4ecb622ce4f21f16716891fb32" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EGPlanner::resetPlanner           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to restart the search from the beginning. 
<p>
The only function available externally to set the planner to the READY state. However, before that can actually happen, the planner must receive all needed input, which depends on the type of implementation.<p>
It will clear any solutions saved so far and re-start the timer and the step count as well. It can not be used while the planner is running, you must pause the planner first. This function will also move the planner from INIT to READY as long as all the necessary conditions for initilized() have been met. 
<p>Reimplemented in <a class="el" href="class_grasp_tester.html#1159f11739140ba3832b6f6315e60222">GraspTester</a>, and <a class="el" href="class_guided_planner.html#9460111f2eb81e6e1bb81682c916e810">GuidedPlanner</a>.</p>

</div>
</div><p>
<a class="anchor" name="dcb78e4d0b233ce826c5d7a532b9d636"></a><!-- doxytag: member="EGPlanner::setState" ref="dcb78e4d0b233ce826c5d7a532b9d636" args="(PlannerState s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EGPlanner::setState           </td>
          <td>(</td>
          <td class="paramtype">PlannerState&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the current state of the planner. 
<p>
Set the current state of the planner. It will accept any state, as long as the current state is not DONE or EXITED. Once the planner is DONE it can only go to EXITED when the thread stops spinning. DONE is essentially just a flag that is guaranteed to stop the thread. There's no going back... 
</div>
</div><p>
<a class="anchor" name="d74401766f6860298ec8c4a0146a94bf"></a><!-- doxytag: member="EGPlanner::showClone" ref="d74401766f6860298ec8c4a0146a94bf" args="(bool s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EGPlanner::showClone           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add (and thus render) or remove (and thus hide) the clone from the world scene graph. 
<p>
The planner can remove the clone from the scene graph. The clone still exists in the collision detection system and can be used normally, it is just not rendered anymore. HIGHLY RECOMMENDED for multi-threaded operation, since Inventor is not thread-safe. The clone should be rendered just for debug purposes. 
</div>
</div><p>
<a class="anchor" name="a3cf97e30a8d892978c00d2a20761927"></a><!-- doxytag: member="EGPlanner::startThread" ref="a3cf97e30a8d892978c00d2a20761927" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EGPlanner::startThread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells the planner to start and run in its own thread. 
<p>
Automatically calls <a class="el" href="class_e_g_planner.html#4b53f60ac4b7bb6d3112136545bcb1d0" title="Tells the planner to create and use a clone of the hand passed to the constructor...">createAndUseClone()</a>. Does not return until new thread is up and ready. However, it does not also start planning, it just spins. Use <a class="el" href="class_e_g_planner.html#d129bfd959b538336874e7349050b92a" title="Start the loops.">startPlanner()</a>, like you would for single-threaded operation, for that. 
</div>
</div><p>
<a class="anchor" name="f0ebf2c8bb0bc108bd7666a227c6945a"></a><!-- doxytag: member="EGPlanner::stopPlanner" ref="f0ebf2c8bb0bc108bd7666a227c6945a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EGPlanner::stopPlanner           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stops the planner FOR GOOD. 
<p>
After this is called, the planner can no longer be re-started. This differentiation is needed mainly for the multi-threaded case: this function stops the planner's thread. 
<p>Reimplemented in <a class="el" href="class_guided_planner.html#09d89d8672d362d0b04bc15ad0d38e99">GuidedPlanner</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/include/EGPlanner/<a class="el" href="eg_planner_8h-source.html">egPlanner.h</a><li>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/debug/moc_egPlanner.cpp<li>C:/Documents and Settings/cmatei/My Documents/GraspitVersions/Graspit-2-1/src/EGPlanner/egPlanner.cpp</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jul 24 16:39:11 2009 for Graspit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
